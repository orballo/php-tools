// ***  SYNTATIC GRAMMAR *** //

// Variables

FUNCTION_STATIC_DECLARATION = { "static" ~ STATIC_VARIABLE_NAME_LIST ~ ";" }
STATIC_VARIABLE_NAME_LIST   = { STATIC_VARIABLE_DECLARATION ~ ("," ~ STATIC_VARIABLE_DECLARATION)* }
STATIC_VARIABLE_DECLARATION = { VARIABLE_NAME ~ FUNCTION_STATIC_INITIALIZER? }
FUNCTION_STATIC_INITIALIZER = { "=" ~ CONSTANT_EXPRESSION }
GLOBAL_DECLARATION          = { "global" ~ VARIABLE_NAME_LIST ~ ";" }
VARIABLE_NAME_LIST          = { SIMPLE_VARIABLE ~ ("," ~ SIMPLE_VARIABLE)* }

// Expressions

PRIMARY_EXPRESSION         = {
    VARIABLE
  | CLASS_CONSTANT_ACCESS_EXPRESSION
  | CONSTANT_ACCESS_EXPRESSION
  | LITERAL
  | ARRAY_CREATION_EXPRESSION
  | INTRINSIC
  | ANONYMOUS_FUNCTION_CREATION_EXPRESSION
  | OBJECT_CREATION_EXPRESSION
  | POSTFIX_INCREMENT_EXPRESSION
  | POSTFIX_DECREMENT_EXPRESSION
  | PREFIX_INCREMENT_EXPRESSION
  | PREFIX_DECREMENT_EXPRESSION
  | BYREF_ASSIGNMENT_EXPRESSION
  | SHELL_COMMAND_EXPRESSION
  | "(" ~ EXPRESSION ~ ")"
}
SIMPLE_VARIABLE            = {
    VARIABLE_NAME
  | "$" ~ (VARIABLE_NAME | "{" ~ EXPRESSION ~ "}")
}
DEREFERENCABLE_EXPRESSION  = {
    VARIABLE
  | "(" ~ EXPRESSION ~ ")"
  | ARRAY_CREATION_EXPRESSION
  | STRING_LITERAL
}
CALLABLE_EXPRESSION        = {
    CALLABLE_VARIABLE
  | "(" ~ EXPRESSION ~ ")"
  | ARRAY_CREATION_EXPRESSION
  | STRING_LITERAL
}
CALLABLE_VARIABLE          = {
    SIMPLE_VARIABLE
  | SUBSCRIPT_EXPRESSION
  | MEMBER_CALL_EXPRESSION
  | SCOPED_CALL_EXPRESSION
  | FUNCTION_CALL_EXPRESSION
}
VARIABLE                   = { CALLABLE_VARIABLE | SCOPED_PROPERTY_ACCESS_EXPRESSION | MEMBER_ACCESS_EXPRESSION }
CONSTANT_ACCESS_EXPRESSION = { QUALIFIED_NAME }
LITERAL                    = { INTEGER_LITERAL | FLOATING_LITERAL | STRING_LITERAL }
INTRINSIC                  = { EMPTY_INTRINSIC | EVAL_INTRINSIC | EXIT_INTRINSIC | ISSET_INTRINSIC }
EMPTY_INTRINSIC            = { "empty" ~ "(" ~ EXPRESSION ~ ")" }
EVAL_INTRINSIC             = { "eval" ~ "(" ~ EXPRESSION ~ ")" }
EXIT_INTRINSIC             = {
    "exit" ~ ("(" ~ EXPRESSION? ~ ")")?
  | "die" ~ ("(" ~ EXPRESSION? ~ ")")?
}
ISSET_INTRINSIC            = { "isset" ~ "(" ~ VARIABLE_LIST ~ ","? ~ ")" }
VARIABLE_LIST              = { VARIABLE ~ ("," ~ VARIABLE)* }
// @TODO: We may need to define white space between keywords
ANONYMOUS_FUNCTION_CREATION_EXPRESSION =  { "static"? ~ "function" ~ "&"? ~ "(" ~ PARAMETER_DECLARATION_LIST? ~ ")" ~ ANONYMOUS_FUNCTION_USE_CLAUSE? ~ RETURN_TYPE? ~ COMPOUND_STATEMENT }
ANONYMOUS_FUNCTION_USE_CLAUSE          =  { "use" ~ "(" ~ USE_VARIABLE_NAME_LIST ~ ")" }
USE_VARIABLE_NAME_LIST                 =  { "&"? ~ VARIABLE_NAME ~ ("," ~ "&"? ~ VARIABLE_NAME)* }
OBJECT_CREATION_EXPRESSION             =  {
    "new" ~ CLASS_TYPE_DESIGNATOR ~ ("(" ~ ARGUMENT_EXPRESSION_LIST? ~ ")")?
  | "new" ~ "class" ~ ("(" ~ ARGUMENT_EXPRESSION_LIST? ~ ")")? ~ CLASS_BASE_CLAUSE? ~ CLASS_INTERFACE_CLAUSE? ~ "{" ~ CLASS_MEMBER_DECLARATIONS? ~ "}"
}
CLASS_TYPE_DESIGNATOR                  = _{ QUALIFIED_NAME | NEW_VARIABLE }
NEW_VARIABLE                           =  { NEW_VARIABLE_BASE ~ NEW_VARIABLE_SUFFIX* }
NEW_VARIABLE_BASE                      = _{
    SIMPLE_VARIABLE
  | QUALIFIED_NAME ~ "::" ~ SIMPLE_VARIABLE
  | RELATIVE_SCOPE ~ "::" ~ SIMPLE_VARIABLE
}
NEW_VARIABLE_SUFFIX                    = _{
    "[" ~ EXPRESSION? ~ "]"
  | "{" ~ EXPRESSION ~ "}"
  | "->" ~ MEMBER_NAME
  | "::" ~ SIMPLE_VARIABLE
}
ARRAY_CREATION_EXPRESSION              =  { "array" ~ "(" ~ ARRAY_INITIALIZER ~ ")" | "[" ~ ARRAY_INITIALIZER ~ "]" }
ARRAY_INITIALIZER                      =  { ARRAY_INITIALIZER_LIST ~ ","? }
ARRAY_INITIALIZER_LIST                 =  { ARRAY_ELEMENT_INITIALIZER ~ ("," ~ ARRAY_ELEMENT_INITIALIZER)* }
ARRAY_ELEMENT_INITIALIZER              = _{
    "&"? ~ ELEMENT_VALUE
  | ELEMENT_KEY ~ "=>" ~ "&"? ~ ELEMENT_VALUE
}
ELEMENT_KEY                            =  { EXPRESSION }
ELEMENT_VALUE                          =  { EXPRESSION }
SUBSCRIPT_EXPRESSION                   =  { DEREFERENCABLE_EXPRESSION ~ ("[" ~ EXPRESSION? ~ "]" | "{" ~ EXPRESSION ~ "}") }
FUNCTION_CALL_EXPRESSION               =  { (QUALIFIED_NAME | CALLABLE_EXPRESSION) ~ "(" ~ (ARGUMENT_EXPRESSION_LIST? | ARGUMENT_EXPRESSION_LIST ~ ",") ~ ")" }
ARGUMENT_EXPRESSION_LIST               =  { ARGUMENT_EXPRESSION ~ ("," ~ ARGUMENT_EXPRESSION)* }
ARGUMENT_EXPRESSION                    =  { VARIADIC_UNPACKING | EXPRESSION }
VARIADIC_UNPACKING                     =  { "..." ~ EXPRESSION }
MEMBER_ACCESS_EXPRESSION               =  { DEREFERENCABLE_EXPRESSION ~ "->" ~ MEMBER_NAME }
MEMBER_NAME                            =  { NAME | SIMPLE_VARIABLE | "{" ~ EXPRESSION ~ "}" }
MEMBER_CALL_EXPRESSION                 =  { DEREFERENCABLE_EXPRESSION ~ "->" ~ MEMBER_NAME ~ "(" ~ (ARGUMENT_EXPRESSION_LIST? | ARGUMENT_EXPRESSION_LIST ~ ",") ~ ")" }
POSTFIX_INCREMENT_EXPRESSION           =  { VARIABLE ~ "++" }
POSTFIX_DECREMENT_EXPRESSION           =  { VARIABLE ~ "--" }
PREFIX_INCREMENT_EXPRESSION            =  { "++" ~ VARIABLE }
PREFIX_DECREMENT_EXPRESSION            =  { "--" ~ VARIABLE }
SHELL_COMMAND_EXPRESSION               =  { "`" ~ DOUBLE_QUOTED_CHARACTER* ~ "`" }
SCOPED_PROPERTY_ACCESS_EXPRESSION      =  { SCOPE_RESOLUTION_QUALIFIER ~ "::" ~ SIMPLE_VARIABLE }
SCOPED_CALL_EXPRESSION                 =  { SCOPE_RESOLUTION_QUALIFIER ~ "::" ~ MEMBER_NAME ~ "(" ~ (ARGUMENT_EXPRESSION_LIST? | ARGUMENT_EXPRESSION_LIST ~ ",") ~ ")" }
CLASS_CONSTANT_ACCESS_EXPRESSION       =  { SCOPE_RESOLUTION_QUALIFIER ~ "::" ~ NAME }
SCOPE_RESOLUTION_QUALIFIER             =  { RELATIVE_SCOPE | QUALIFIED_NAME | DEREFERENCABLE_EXPRESSION }
RELATIVE_SCOPE                         =  { "self" | "parent" | "static" }
CLONE_EXPRESSION                       =  { PRIMARY_EXPRESSION | "clone" ~ PRIMARY_EXPRESSION }
EXPONENTIATION_EXPRESSION              =  { CLONE_EXPRESSION | CLONE_EXPRESSION ~ "**" ~ EXPONENTIATION_EXPRESSION }
UNARY_EXPRESSION                       =  {
    EXPONENTIATION_EXPRESSION
  | UNARY_OPERATOR_EXPRESSION
  | ERROR_CONTROL_EXPRESSION
  | CAST_EXPRESSION
}
UNARY_OPERATOR_EXPRESSION              =  { UNARY_OPERATOR ~ UNARY_EXPRESSION }
UNARY_OPERATOR                         =  { "+" | "-" | "~" }
ERROR_CONTROL_EXPRESSION               =  { "@" ~ UNARY_EXPRESSION }
CAST_EXPRESSION                        =  { "(" ~ CAST_TYPE ~ ")" ~ UNARY_EXPRESSION }
CAST_TYPE                              =  { "array" | "binary" | "bool" | "boolean" | "double" | "int" | "integer" | "float" | "object" | "real" | "string" | "unset" }
INSTANCEOF_EXPRESSION                  =  { UNARY_EXPRESSION | INSTANCEOF_SUBJECT ~ "instanceof" ~ CLASS_TYPE_DESIGNATOR }
INSTANCEOF_SUBJECT                     =  { INSTANCEOF_EXPRESSION }
LOGICAL_NOT_EXPRESSION                 =  { INSTANCEOF_EXPRESSION | "!" ~ INSTANCEOF_EXPRESSION }
MULTIPLICATIVE_EXPRESSION              =  { LOGICAL_NOT_EXPRESSION ~ (("*" | "/" | "%") ~ LOGICAL_NOT_EXPRESSION)* }
ADDITIVE_EXPRESSION                    =  { MULTIPLICATIVE_EXPRESSION ~ (("+" | "-" | ".") ~ MULTIPLICATIVE_EXPRESSION)* }
SHIFT_EXPRESSION                       =  { ADDITIVE_EXPRESSION ~ (("<<" | ">>") ~ ADDITIVE_EXPRESSION)* }
RELATIONAL_EXPRESSION                  =  { SHIFT_EXPRESSION ~ (("<" | ">" | "<=" | ">=" | "<=>") ~ SHIFT_EXPRESSION)* }
EQUALITY_EXPRESSION                    =  { RELATIONAL_EXPRESSION ~ (("==" | "!=" | "<>" | "===" | "!==") ~ RELATIONAL_EXPRESSION)* }
BITWISE_AND_EXPRESSION                 =  { EQUALITY_EXPRESSION ~ ("&" ~ EQUALITY_EXPRESSION)* }
BITWISE_EXC_OR_EXPRESSION              =  { BITWISE_AND_EXPRESSION ~ ("^" ~ BITWISE_AND_EXPRESSION)* }
BITWISE_INC_OR_EXPRESSION              =  { BITWISE_EXC_OR_EXPRESSION ~ ("|" ~ BITWISE_EXC_OR_EXPRESSION)* }
LOGICAL_AND_EXPRESSION_1               =  { BITWISE_INC_OR_EXPRESSION ~ ("&&" ~ BITWISE_INC_OR_EXPRESSION)* }
LOGICAL_INC_OR_EXPRESSION_1            =  { LOGICAL_AND_EXPRESSION_1 ~ ("||" ~ LOGICAL_AND_EXPRESSION_1)* }
COALESCE_EXPRESSION                    =  { LOGICAL_INC_OR_EXPRESSION_1 ~ ("??" ~ COALESCE_EXPRESSION)? }
CONDITIONAL_EXPRESSION                 =  { COALESCE_EXPRESSION ~ ("?" ~ EXPRESSION? ~ ":" ~ COALESCE_EXPRESSION)* }
ASSIGNMENT_EXPRESSION                  =  {
    CONDITIONAL_EXPRESSION
  | SIMPLE_ASSIGNMENT_EXPRESSION
  | COMPOUND_ASSIGNMENT_EXPRESSION
}
SIMPLE_ASSIGNMENT_EXPRESSION           =  { (VARIABLE | LIST_INTRINSIC) ~ "=" ~ ASSIGNMENT_EXPRESSION }
LIST_INTRINSIC                         =  { "list" ~ "(" ~ LIST_EXPRESSION_LIST ~ ")" }
LIST_EXPRESSION_LIST                   =  { UNKEYED_LIST_EXPRESSION_LIST | KEYED_LIST_EXPRESSION_LIST ~ ","? }
UNKEYED_LIST_EXPRESSION_LIST           =  { (LIST_OR_VARIABLE | ",") ~ ("," ~ LIST_OR_VARIABLE?)* }
KEYED_LIST_EXPRESSION_LIST             =  { EXPRESSION ~ "=>" ~ LIST_OR_VARIABLE ~ ("," ~ EXPRESSION ~ "=>" ~ LIST_OR_VARIABLE)* }
LIST_OR_VARIABLE                       =  { LIST_INTRINSIC | "&"? ~ VARIABLE }
BYREF_ASSIGNMENT_EXPRESSION            =  { VARIABLE ~ "=" ~ "&" ~ VARIABLE }
COMPOUND_ASSIGNMENT_EXPRESSION         =  { VARIABLE ~ COMPOUND_ASSIGNMENT_OPERATOR ~ ASSIGNMENT_EXPRESSION }
COMPOUND_ASSIGNMENT_OPERATOR           =  { "**=" | "*=" | "/=" | "%=" | "+=" | "-=" | ".=" | "<<=" | ">>=" | "&=" | "^=" | "|=" }
YIELD_FROM_EXPRESSION                  =  { "yield from" ~ ASSIGNMENT_EXPRESSION }
YIELD_EXPRESSION                       =  { "yield" ~ ((YIELD_FROM_EXPRESSION ~ "=>")? ~ YIELD_EXPRESSION)? | YIELD_FROM_EXPRESSION }
PRINT_EXPRESSION                       =  { YIELD_EXPRESSION | "print" ~ PRINT_EXPRESSION }
LOGICAL_AND_EXPRESSION_2               =  { PRINT_EXPRESSION ~ ("and" ~ YIELD_EXPRESSION)* }
LOGICAL_EXC_OR_EXPRESSION              =  { LOGICAL_AND_EXPRESSION_2 ~ ("xor" ~ LOGICAL_AND_EXPRESSION_2)* }
LOGICAL_INC_OR_EXPRESSION_2            =  { LOGICAL_EXC_OR_EXPRESSION ~ ("or" ~ LOGICAL_EXC_OR_EXPRESSION)* }
EXPRESSION                             =  {
    LOGICAL_INC_OR_EXPRESSION_2
  | INCLUDE_EXPRESSION
  | INCLUDE_ONCE_EXPRESSION
  | REQUIRE_EXPRESSION
  | REQUIRE_ONCE_EXPRESSION
}
INCLUDE_EXPRESSION                     =  { "include" ~ EXPRESSION }
INCLUDE_ONCE_EXPRESSION                =  { "include_once" ~ EXPRESSION }
REQUIRE_EXPRESSION                     =  { "require" ~ EXPRESSION }
REQUIRE_ONCE_EXPRESSION                =  { "require_once" ~ EXPRESSION }
CONSTANT_EXPRESSION                    =  { EXPRESSION }

// Statements

// This rule defines the various types of statements in PHP.
// It includes compound statements, named label statements, expression statements,
// selection statements (like if and switch), iteration statements (like for and while),
// jump statements (like break and continue), try-catch statements, declare statements,
// echo statements, unset statements, constant declarations, function definitions,
// class declarations, interface declarations, trait declarations, namespace definitions,
// namespace use declarations, global declarations, and function static declarations.
// Each of these statement types is defined in more detail in other rules of the grammar.
STATEMENT                     = _{
    COMPOUND_STATEMENT
  | NAMED_LABEL_STATEMENT
  | EXPRESSION_STATEMENT
  | SELECTION_STATEMENT
  | ITERATION_STATEMENT
  | JUMP_STATEMENT
  | TRY_STATEMENT
  | DECLARE_STATEMENT
  | ECHO_STATEMENT
  | UNSET_STATEMENT
  | CONST_DECLARATION
  | FUNCTION_DEFINITION
  | CLASS_DECLARATION
  | INTERFACE_DECLARATION
  | TRAIT_DECLARATION
  | NAMESPACE_DEFINITION
  | NAMESPACE_USE_DECLARATION
  | GLOBAL_DECLARATION
  | FUNCTION_STATIC_DECLARATION
}
COMPOUND_STATEMENT            =  { "{" ~ STATEMENT_LIST? ~ "}" }
STATEMENT_LIST                =  { STATEMENT+ }
NAMED_LABEL_STATEMENT         =  { NAME ~ ":" }
EXPRESSION_STATEMENT          =  { EXPRESSION? ~ ";" }
SELECTION_STATEMENT           =  { IF_STATEMENT | SWITCH_STATEMENT }
IF_STATEMENT                  =  { "if" ~ "(" ~ EXPRESSION ~ ")" ~ (STATEMENT ~ ELSEIF_CLAUSES_1? ~ ELSE_CLAUSE_1? | ":" ~ STATEMENT_LIST ~ ELSEIF_CLAUSES_2? ~ ELSE_CLAUSE_2? ~ "endif" ~ ";") }
ELSEIF_CLAUSES_1              =  { ELSEIF_CLAUSE_1+ }
ELSEIF_CLAUSE_1               =  { "elseif" ~ "(" ~ EXPRESSION ~ ")" ~ STATEMENT }
ELSE_CLAUSE_1                 =  { "else" ~ STATEMENT }
ELSEIF_CLAUSES_2              =  { ELSEIF_CLAUSE_2+ }
ELSEIF_CLAUSE_2               =  { "elseif" ~ "(" ~ EXPRESSION ~ ")" ~ ":" ~ STATEMENT_LIST }
ELSE_CLAUSE_2                 =  { "else" ~ ":" ~ STATEMENT_LIST }
SWITCH_STATEMENT              =  { "switch" ~ "(" ~ EXPRESSION ~ ")" ~ ("{" ~ CASE_STATEMENTS? ~ "}" | ":" ~ CASE_STATEMENTS? ~ "endswitch" ~ ";") }
CASE_STATEMENTS               =  { (CASE_STATEMENT | DEFAULT_STATEMENT)+ }
CASE_STATEMENT                =  { "case" ~ EXPRESSION ~ CASE_DEFAULT_LABEL_TERMINATOR ~ STATEMENT_LIST? }
DEFAULT_STATEMENT             =  { "default" ~ CASE_DEFAULT_LABEL_TERMINATOR ~ STATEMENT_LIST? }
CASE_DEFAULT_LABEL_TERMINATOR =  { ":" | ";" }
ITERATION_STATEMENT           =  {
    WHILE_STATEMENT
  | DO_STATEMENT
  | FOR_STATEMENT
  | FOREACH_STATEMENT
}
WHILE_STATEMENT               =  { "while" ~ "(" ~ EXPRESSION ~ ")" ~ (STATEMENT | ":" ~ STATEMENT_LIST ~ "endwhile" ~ ";") }
DO_STATEMENT                  =  { "do" ~ STATEMENT ~ "while" ~ "(" ~ EXPRESSION ~ ")" ~ ";" }
FOR_STATEMENT                 =  { "for" ~ "(" ~ FOR_INITIALIZER? ~ ";" ~ FOR_CONTROL? ~ ";" ~ FOR_END_OF_LOOP? ~ ")" ~ (STATEMENT | ":" ~ STATEMENT_LIST ~ "endfor" ~ ";") }
FOR_INITIALIZER               =  { FOR_EXPRESSION_GROUP }
FOR_CONTROL                   =  { FOR_EXPRESSION_GROUP }
FOR_END_OF_LOOP               =  { FOR_EXPRESSION_GROUP }
FOR_EXPRESSION_GROUP          =  { EXPRESSION ~ ("," ~ EXPRESSION)* }
FOREACH_STATEMENT             =  { "foreach" ~ "(" ~ FOREACH_COLLECTION_NAME ~ "as" ~ FOREACH_KEY? ~ FOREACH_VALUE ~ ")" ~ (STATEMENT | ":" ~ STATEMENT_LIST ~ "endforeach" ~ ";") }
FOREACH_COLLECTION_NAME       =  { EXPRESSION }
FOREACH_KEY                   =  { EXPRESSION ~ "=>" }
FOREACH_VALUE                 =  { "&"? ~ EXPRESSION | LIST_INTRINSIC }
JUMP_STATEMENT                =  {
    GOTO_STATEMENT
  | CONTINUE_STATEMENT
  | BREAK_STATEMENT
  | RETURN_STATEMENT
  | THROW_STATEMENT
}
GOTO_STATEMENT                =  { "goto" ~ NAME ~ ";" }
CONTINUE_STATEMENT            =  { "continue" ~ BREAKOUT_LEVEL? ~ ";" }
BREAKOUT_LEVEL                =  { INTEGER_LITERAL | "(" ~ BREAKOUT_LEVEL ~ ")" }
BREAK_STATEMENT               =  { "break" ~ BREAKOUT_LEVEL? ~ ";" }
RETURN_STATEMENT              =  { "return" ~ EXPRESSION? ~ ";" }
THROW_STATEMENT               =  { "throw" ~ EXPRESSION ~ ";" }
TRY_STATEMENT                 =  { "try" ~ COMPOUND_STATEMENT ~ (CATCH_CLAUSES | FINALLY_CLAUSE | CATCH_CLAUSES ~ FINALLY_CLAUSE) }
CATCH_CLAUSES                 =  { CATCH_CLAUSE+ }
CATCH_CLAUSE                  =  { "catch" ~ "(" ~ CATCH_NAME_LIST ~ VARIABLE_NAME ~ ")" ~ COMPOUND_STATEMENT }
CATCH_NAME_LIST               =  { QUALIFIED_NAME ~ ("|" ~ QUALIFIED_NAME)* }
FINALLY_CLAUSE                =  { "finally" ~ COMPOUND_STATEMENT }
DECLARE_STATEMENT             =  { "declare" ~ "(" ~ DECLARE_DIRECTIVE ~ ")" ~ (STATEMENT | ":" ~ STATEMENT_LIST ~ "enddeclare" ~ ";" | ";") }
DECLARE_DIRECTIVE             =  {
    "ticks" ~ "=" ~ LITERAL
  | "encoding" ~ "=" ~ LITERAL
  | "strict_types" ~ "=" ~ LITERAL
}
ECHO_STATEMENT                =  { "echo" ~ EXPRESSION_LIST ~ ";" }
EXPRESSION_LIST               =  { EXPRESSION ~ ("," ~ EXPRESSION)* }
UNSET_STATEMENT               =  { "unset" ~ "(" ~ VARIABLE_LIST ~ ","? ~ ")" ~ ";" }

// Functions

FUNCTION_DEFINITION               = { FUNCTION_DEFINITION_HEADER ~ COMPOUND_STATEMENT }
FUNCTION_DEFINITION_HEADER        = { "function" ~ "&"? ~ NAME ~ "(" ~ PARAMETER_DECLARATION_LIST? ~ ")" ~ RETURN_TYPE? }
PARAMETER_DECLARATION_LIST        = { SIMPLE_PARAMETER_DECLARATION_LIST | VARIADIC_DECLARATION_LIST }
SIMPLE_PARAMETER_DECLARATION_LIST = { PARAMETER_DECLARATION ~ ("," ~ PARAMETER_DECLARATION)* }
VARIADIC_DECLARATION_LIST         = { (SIMPLE_PARAMETER_DECLARATION_LIST ~ ",")? ~ VARIADIC_PARAMETER }
PARAMETER_DECLARATION             = { TYPE_DECLARATION? ~ "&"? ~ VARIABLE_NAME ~ DEFAULT_ARGUMENT_SPECIFIER? }
VARIADIC_PARAMETER                = { TYPE_DECLARATION? ~ "&"? ~ "..." ~ VARIABLE_NAME }
RETURN_TYPE                       = { ":" ~ (TYPE_DECLARATION | "void") }
TYPE_DECLARATION                  = { "?"? ~ BASE_TYPE_DECLARATION }
BASE_TYPE_DECLARATION             = { "array" | "callable" | "iterable" | SCALAR_TYPE | QUALIFIED_NAME }
SCALAR_TYPE                       = { "bool" | "float" | "int" | "string" }
DEFAULT_ARGUMENT_SPECIFIER        = { "=" ~ CONSTANT_EXPRESSION }

// Classes

CLASS_DECLARATION         = { CLASS_MODIFIER? ~ "class" ~ NAME ~ CLASS_BASE_CLAUSE? ~ CLASS_INTERFACE_CLAUSE? ~ "{" ~ CLASS_MEMBER_DECLARATIONS? ~ "}" }
CLASS_MODIFIER            = { "abstract" | "final" }
CLASS_BASE_CLAUSE         = { "extends" ~ QUALIFIED_NAME }
CLASS_INTERFACE_CLAUSE    = { "implements" ~ QUALIFIED_NAME ~ ("," ~ QUALIFIED_NAME)* }
CLASS_MEMBER_DECLARATIONS = { CLASS_MEMBER_DECLARATION+ }
CLASS_MEMBER_DECLARATION  = {
    CLASS_CONST_DECLARATION
  | PROPERTY_DECLARATION
  | METHOD_DECLARATION
  | CONSTRUCTOR_DECLARATION
  | DESTRUCTOR_DECLARATION
  | TRAIT_USE_CLAUSE
}
CONST_DECLARATION         = { "const" ~ CONST_ELEMENTS ~ ";" }
CLASS_CONST_DECLARATION   = { VISIBILITY_MODIFIER? ~ "const" ~ CONST_ELEMENTS ~ ";" }
CONST_ELEMENTS            = { CONST_ELEMENT ~ ("," ~ CONST_ELEMENT)* }
CONST_ELEMENT             = { NAME ~ "=" ~ CONSTANT_EXPRESSION }
PROPERTY_DECLARATION      = { PROPERTY_MODIFIER ~ PROPERTY_ELEMENTS ~ ";" }
PROPERTY_MODIFIER         = {
    "var"
  | VISIBILITY_MODIFIER ~ STATIC_MODIFIER?
  | STATIC_MODIFIER ~ VISIBILITY_MODIFIER?
}
VISIBILITY_MODIFIER       = { "public" | "protected" | "private" }
STATIC_MODIFIER           = { "static" }
PROPERTY_ELEMENTS         = { PROPERTY_ELEMENT+ }
PROPERTY_ELEMENT          = { VARIABLE_NAME ~ PROPERTY_INITIALIZER? ~ ";" }
PROPERTY_INITIALIZER      = { "=" ~ CONSTANT_EXPRESSION }
METHOD_DECLARATION        = {
    METHOD_MODIFIERS? ~ FUNCTION_DEFINITION
  | METHOD_MODIFIERS ~ FUNCTION_DEFINITION_HEADER ~ ";"
}
METHOD_MODIFIERS          = { METHOD_MODIFIER+ }
METHOD_MODIFIER           = { VISIBILITY_MODIFIER | STATIC_MODIFIER | CLASS_MODIFIER }
CONSTRUCTOR_DECLARATION   = { METHOD_MODIFIERS ~ "function" ~ "&"? ~ "__construct" ~ "(" ~ PARAMETER_DECLARATION_LIST? ~ ")" ~ COMPOUND_STATEMENT }
DESTRUCTOR_DECLARATION    = { METHOD_MODIFIERS ~ "function" ~ "&"? ~ "__destruct" ~ "(" ~ ")" ~ COMPOUND_STATEMENT }

// Interfaces

INTERFACE_DECLARATION         = { "interface" ~ NAME ~ INTERFACE_BASE_CLAUSE? ~ "{" ~ INTERFACE_MEMBER_DECLARATIONS? ~ "}" }
INTERFACE_BASE_CLAUSE         = { "extends" ~ QUALIFIED_NAME ~ ("," ~ QUALIFIED_NAME)* }
INTERFACE_MEMBER_DECLARATIONS = { INTERFACE_MEMBER_DECLARATION+ }
INTERFACE_MEMBER_DECLARATION  = { CLASS_CONST_DECLARATION | METHOD_DECLARATION }

// Traits

TRAIT_DECLARATION              = { "trait" ~ NAME ~ "{" ~ TRAIT_MEMBER_DECLARATIONS? ~ "}" }
TRAIT_MEMBER_DECLARATIONS      = { TRAIT_MEMBER_DECLARATION+ }
TRAIT_MEMBER_DECLARATION       = {
    PROPERTY_DECLARATION
  | METHOD_DECLARATION
  | CONSTRUCTOR_DECLARATION
  | DESTRUCTOR_DECLARATION
  | TRAIT_USE_CLAUSES
}
TRAIT_USE_CLAUSES              = { TRAIT_USE_CLAUSE+ }
TRAIT_USE_CLAUSE               = { "use" ~ TRAIT_NAME_LIST ~ TRAIT_USE_SPECIFICATION }
TRAIT_NAME_LIST                = { QUALIFIED_NAME ~ ("," ~ QUALIFIED_NAME)* }
TRAIT_USE_SPECIFICATION        = { ";" | "{" ~ TRAIT_SELECT_AND_ALIAS_CLAUSES? ~ "}" }
TRAIT_SELECT_AND_ALIAS_CLAUSES = { TRAIT_SELECT_AND_ALIAS_CLAUSE+ }
TRAIT_SELECT_AND_ALIAS_CLAUSE  = { TRAIT_SELECT_INSTEADOF_CLAUSE ~ ";" | TRAIT_ALIAS_AS_CLAUSE ~ ";" }
TRAIT_SELECT_INSTEADOF_CLAUSE  = { QUALIFIED_NAME ~ "::" ~ NAME ~ "insteadof" ~ TRAIT_NAME_LIST }
TRAIT_ALIAS_AS_CLAUSE          = {
    NAME ~ "as" ~ VISIBILITY_MODIFIER? ~ NAME
  | NAME ~ "as" ~ VISIBILITY_MODIFIER ~ NAME?
}

// Namespaces

NAMESPACE_DEFINITION          = {
    "namespace" ~ NAMESPACE_NAME ~ ";"
  | "namespace" ~ NAMESPACE_NAME? ~ COMPOUND_STATEMENT
}
NAMESPACE_USE_DECLARATION     = {
    "use" ~ NAMESPACE_FUNCTION_OR_CONST? ~ NAMESPACE_USE_CLAUSES ~ ";"
  | "use" ~ NAMESPACE_FUNCTION_OR_CONST ~ "\\"? ~ NAMESPACE_NAME ~ "\\" ~ "{" ~ NAMESPACE_USE_GROUP_CLAUSES_1 ~ "}" ~ ";"
  | "use" ~ "\\"? ~ NAMESPACE_NAME ~ "\\" ~ "{" ~ NAMESPACE_USE_GROUP_CLAUSES_2 ~ "}" ~ ";"
}
NAMESPACE_USE_CLAUSES         = { NAMESPACE_USE_CLAUSE ~ ("," ~ NAMESPACE_USE_CLAUSE)* }
NAMESPACE_USE_CLAUSE          = { QUALIFIED_NAME ~ NAMESPACE_ALIASING_CLAUSE? }
NAMESPACE_ALIASING_CLAUSE     = { "as" ~ NAME }
NAMESPACE_FUNCTION_OR_CONST   = { "function" | "const" }
NAMESPACE_USE_GROUP_CLAUSES_1 = { NAMESPACE_USE_GROUP_CLAUSE_1 ~ ("," ~ NAMESPACE_USE_GROUP_CLAUSE_1)* }
NAMESPACE_USE_GROUP_CLAUSE_1  = { NAMESPACE_NAME ~ NAMESPACE_ALIASING_CLAUSE? }
NAMESPACE_USE_GROUP_CLAUSES_2 = { NAMESPACE_USE_GROUP_CLAUSE_2 ~ ("," ~ NAMESPACE_USE_GROUP_CLAUSE_2)* }
NAMESPACE_USE_GROUP_CLAUSE_2  = { NAMESPACE_FUNCTION_OR_CONST? ~ NAMESPACE_NAME ~ NAMESPACE_ALIASING_CLAUSE? }
