// Root

FILE = { SOI ~ SCRIPT ~ EOI }

// ***  LEXICAL GRAMMAR *** //

// Input

INPUT_FILE       =  { INPUT_ELEMENT+ }
INPUT_ELEMENT    = _{ COMMENT | WHITE_SPACE | TOKEN }
INPUT_CHARACTERS = _{ INPUT_CHARACTER+ }
INPUT_CHARACTER  = _{ (!NEW_LINE ~ ANY) }

// Comments

COMMENT             = _{ SINGLE_LINE_COMMENT | DELIMITED_COMMENT }
SINGLE_LINE_COMMENT = _{ "//" ~ INPUT_CHARACTERS? }
DELIMITED_COMMENT   = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Whitespace

WHITE_SPACE           = _{ WHITE_SPACE_CHARACTER+ }
WHITE_SPACE_CHARACTER = _{ NEW_LINE | " " | "\t" }
NEW_LINE              = _{ "\r" | "\n" | "\r\n" }

// Tokens

TOKEN = {
    VARIABLE_NAME
  | NAME
  | KEYWORD
  | INTEGER_LITERAL
  | FLOATING_LITERAL
  | STRING_LITERAL
  | OPERATOR_OR_PUNCTUATOR
}

// Names

VARIABLE_NAME              =  { "$" ~ NAME }
NAMESPACE_NAME             =  { NAME ~ ("\\" ~ NAME)* }
NAMESPACE_NAME_AS_A_PREFIX =  {
    "\\"
  | ("\\"? ~ NAMESPACE_NAME ~ "\\")
  | ("namespace" ~ "\\")
  | ("namespace" ~ "\\" ~ NAMESPACE_NAME ~ "\\")
}
QUALIFIED_NAME             =  { NAMESPACE_NAME_AS_A_PREFIX? ~ NAME }
NAME                       =  { NAME_NONDIGIT ~ (NAME_NONDIGIT | ASCII_DIGIT)* }
NAME_NONDIGIT              = _{ NONDIGIT | '\u{80}'..'\u{FF}' }
NONDIGIT                   = _{ "_" | ASCII_ALPHA }

// Keywords

KEYWORD      = {
    ABSTRACT
  | AND
  | ARRAY
  | AS
  | BREAK
  | CALLABLE
  | CASE
  | CATCH
  | CLASS
  | CLONE
  | CONST
  | CONTINUE
  | DECLARE
  | DEFAULT
  | DIE
  | DO
  | ECHO
  | ELSE
  | ELSEIF
  | EMPTY
  | ENDDECLARE
  | ENDFOR
  | ENDFOREACH
  | ENDIF
  | ENDSWITCH
  | ENDWHILE
  | EVAL
  | EXIT
  | EXTENDS
  | FINAL
  | FINALLY
  | FOR
  | FOREACH
  | FUNCTION
  | GLOBAL
  | GOTO
  | IF
  | IMPLEMENTS
  | INCLUDE
  | INCLUDE_ONCE
  | INSTANCEOF
  | INSTEADOF
  | INTERFACE
  | ISSET
  | LIST
  | NAMESPACE
  | NEW
  | OR
  | PRINT
  | PRIVATE
  | PROTECTED
  | PUBLIC
  | REQUIRE
  | REQUIRE_ONCE
  | RETURN
  | STATIC
  | SWITCH
  | THROW
  | TRAIT
  | TRY
  | UNSET
  | USE
  | VAR
  | WHILE
  | XOR
  | YIELD
  | YIELD_FROM
}
ABSTRACT     = { "abstract" }
AND          = { "and" }
ARRAY        = { "array" }
AS           = { "as" }
BREAK        = { "break" }
CALLABLE     = { "callable" }
CASE         = { "case" }
CATCH        = { "catch" }
CLASS        = { "class" }
CLONE        = { "clone" }
CONST        = { "const" }
CONTINUE     = { "continue" }
DECLARE      = { "declare" }
DEFAULT      = { "default" }
DIE          = { "die" }
DO           = { "do" }
ECHO         = { "echo" }
ELSE         = { "else" }
ELSEIF       = { "elseif" }
EMPTY        = { "empty" }
ENDDECLARE   = { "enddeclare" }
ENDFOR       = { "endfor" }
ENDFOREACH   = { "endforeach" }
ENDIF        = { "endif" }
ENDSWITCH    = { "endswitch" }
ENDWHILE     = { "endwhile" }
EVAL         = { "eval" }
EXIT         = { "exit" }
EXTENDS      = { "extends" }
FINAL        = { "final" }
FINALLY      = { "finally" }
FOR          = { "for" }
FOREACH      = { "foreach" }
FUNCTION     = { "function" }
GLOBAL       = { "global" }
GOTO         = { "goto" }
IF           = { "if" }
IMPLEMENTS   = { "implements" }
INCLUDE      = { "include" }
INCLUDE_ONCE = { "include_once" }
INSTANCEOF   = { "instanceof" }
INSTEADOF    = { "insteadof" }
INTERFACE    = { "interface" }
ISSET        = { "isset" }
LIST         = { "list" }
NAMESPACE    = { "namespace" }
NEW          = { "new" }
OR           = { "or" }
PRINT        = { "print" }
PRIVATE      = { "private" }
PROTECTED    = { "protected" }
PUBLIC       = { "public" }
REQUIRE      = { "require" }
REQUIRE_ONCE = { "require_once" }
RETURN       = { "return" }
STATIC       = { "static" }
SWITCH       = { "switch" }
THROW        = { "throw" }
TRAIT        = { "trait" }
TRY          = { "try" }
UNSET        = { "unset" }
USE          = { "use" }
VAR          = { "var" }
WHILE        = { "while" }
XOR          = { "xor" }
YIELD        = { "yield" }
YIELD_FROM   = { "yield from" }

// Integer Literal

INTEGER_LITERAL     = {
    DECIMAL_LITERAL
  | OCTAL_LITERAL
  | HEXADECIMAL_LITERAL
  | BINARY_LITERAL
}
DECIMAL_LITERAL     = { ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
OCTAL_LITERAL       = { "0" ~ ASCII_OCT_DIGIT+ }
HEXADECIMAL_LITERAL = { "0" ~ ^"x" ~ ASCII_HEX_DIGIT+ }
BINARY_LITERAL      = { "0" ~ ^"b" ~ ASCII_BIN_DIGIT+ }

// Floating Literal

FLOATING_LITERAL   =  { (FRACTIONAL_LITERAL ~ EXPONENT_PART?) | (ASCII_DIGIT+ ~ EXPONENT_PART) }
FRACTIONAL_LITERAL =  { (ASCII_DIGIT* ~ "." ~ ASCII_DIGIT+) | (ASCII_DIGIT+ ~ ".") }
EXPONENT_PART      = _{ ^"e" ~ SIGN? ~ ASCII_DIGIT+ }
SIGN               =  { "+" | "-" }

// String Literal

STRING_LITERAL                            =  {
    SINGLE_QUOTED_STRING_LITERAL
  | DOUBLE_QUOTED_STRING_LITERAL
  | HEREDOC_STRING_LITERAL
  | NOWDOC_STRING_LITERAL
}
SINGLE_QUOTED_STRING_LITERAL              =  { BINARY_PREFIX? ~ "'" ~ SINGLE_QUOTED_CHARACTER* ~ "'" }
SINGLE_QUOTED_CHARACTER                   =  { SINGLE_QUOTED_ESCAPE_SEQUENCE | !("'" | "\\") ~ ANY }
SINGLE_QUOTED_ESCAPE_SEQUENCE             =  { "\\'" | "\\\\" }
BINARY_PREFIX                             =  { ^"b" }
DOUBLE_QUOTED_STRING_LITERAL              =  { BINARY_PREFIX? ~ "\"" ~ DOUBLE_QUOTED_CHARACTER* ~ "\"" }
DOUBLE_QUOTED_CHARACTER                   =  {
    DOUBLE_QUOTED_ESCAPE_SEQUENCE
  | !("\"" | "\\") ~ ANY
  | "\\" ~ !("\"" | "\\" | "$" | "e" | "f" | "n" | "r" | "t" | "v" | ^"x" | ASCII_OCT_DIGIT) ~ ANY
}
DOUBLE_QUOTED_ESCAPE_SEQUENCE             =  {
    DOUBLE_QUOTED_SIMPLE_ESCAPE_SEQUENCE
  | DOUBLE_QUOTED_OCTAL_ESCAPE_SEQUENCE
  | DOUBLE_QUOTED_HEXADECIMAL_ESCAPE_SEQUENCE
  | DOUBLE_QUOTED_UNICODE_ESCAPE_SEQUENCE
}
DOUBLE_QUOTED_SIMPLE_ESCAPE_SEQUENCE      = _{ "\\\"" | "\\\\" | "\\$" | "\\e" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v" }
DOUBLE_QUOTED_OCTAL_ESCAPE_SEQUENCE       = _{ "\\" ~ ASCII_OCT_DIGIT{1, 3} }
DOUBLE_QUOTED_HEXADECIMAL_ESCAPE_SEQUENCE = _{ "\\" ~ ^"x" ~ ASCII_HEX_DIGIT{1, 2} }
DOUBLE_QUOTED_UNICODE_ESCAPE_SEQUENCE     = _{ "\\u" ~ "{" ~ ASCII_HEX_DIGIT+ ~ "}" }
STRING_VARIABLE                           =  { VARIABLE_NAME ~ OFFSET_OR_PROPERTY? | "{$" ~ EXPRESSION ~ "}" }
OFFSET_OR_PROPERTY                        =  { OFFSET_IN_STRING | PROPERTY_IN_STRING }
OFFSET_IN_STRING                          =  { "[" ~ (NAME | VARIABLE_NAME | INTEGER_LITERAL) ~ "]" }
PROPERTY_IN_STRING                        =  { "->" ~ NAME }
HEREDOC_STRING_LITERAL                    =  { BINARY_PREFIX? ~ "<<<" ~ HEREDOC_START_IDENTIFIER ~ NEW_LINE ~ HEREDOC_BODY? ~ HEREDOC_END_IDENTIFIER ~ ";"? ~ NEW_LINE }
HEREDOC_START_IDENTIFIER                  =  { NAME | ("\"") ~ NAME ~ ("\"") }
HEREDOC_END_IDENTIFIER                    =  { NAME }
HEREDOC_BODY                              =  { HEREDOC_CHAR* ~ NEW_LINE }
HEREDOC_CHAR                              = _{
    HEREDOC_ESCAPE_SEQUENCE
  | !"\\" ~ ANY
  | "\\" ~ !("\\" | "$" | "e" | "f" | "n" | "r" | "t" | "v" | ^"x" | ASCII_OCT_DIGIT) ~ ANY
}
HEREDOC_ESCAPE_SEQUENCE                   =  {
    HEREDOC_SIMPLE_ESCAPE_SEQUENCE
  | DOUBLE_QUOTED_OCTAL_ESCAPE_SEQUENCE
  | DOUBLE_QUOTED_HEXADECIMAL_ESCAPE_SEQUENCE
  | DOUBLE_QUOTED_UNICODE_ESCAPE_SEQUENCE
}
HEREDOC_SIMPLE_ESCAPE_SEQUENCE            = _{ "\\\\" | "\\$" | "\\e" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v" }
NOWDOC_STRING_LITERAL                     =  { BINARY_PREFIX? ~ "<<<" ~ "'" ~ NAME ~ "'" ~ NEW_LINE ~ HEREDOC_BODY? ~ NAME ~ ";"? ~ NEW_LINE }

// Operators and Punctuators

OPERATOR_OR_PUNCTUATOR = _{
    DOT
  | OBJECT_ARROW
  | INCREMENT
  | DECREMENT
  | EXPONENTIATION
  | MULTIPLICATION
  | ADDITION
  | SUBTRACTION
  | BITWISE_NOT
  | LOGICAL_NOT
  | DIVISION
  | MODULUS
  | BITWISE_LEFT_SHIFT
  | BITWISE_RIGHT_SHIFT
  | LESS_THAN
  | GREATER_THAN
  | LESS_THAN_OR_EQUAL
  | GREATER_THAN_OR_EQUAL
  | EQUALITY
  | IDENTITY
  | INEQUALITY
  | NON_IDENTITY
  | BITWISE_XOR
  | BITWISE_OR
  | BITWISE_AND
  | LOGICAL_AND
  | LOGICAL_OR
  | TERNARY_CONDITION
  | TERNARY_SEPARATOR
  | ASSIGNMENT
  | EXPONENTIATION_ASSIGNMENT
  | MULTIPLICATION_ASSIGNMENT
  | DIVISION_ASSIGNMENT
  | MODULUS_ASSIGNMENT
  | ADDITION_ASSIGNMENT
  | SUBTRACTION_ASSIGNMENT
  | CONCATENATION_ASSIGNMENT
  | BITWISE_LEFT_SHIFT_ASSIGNMENT
  | BITWISE_RIGHT_SHIFT_ASSIGNMENT
  | BITWISE_AND_ASSIGNMENT
  | BITWISE_XOR_ASSIGNMENT
  | BITWISE_OR_ASSIGNMENT
  | NULL_COALESCING
  | SCOPE_RESOLUTION
  | ARRAY_ARROW
  | SPACESHIP
  | ELLIPSIS
  | LEFT_SQUARE_BRACKET
  | RIGHT_SQUARE_BRACKET
  | LEFT_PARENTHESIS
  | RIGHT_PARENTHESIS
  | LEFT_CURLY_BRACE
  | RIGHT_CURLY_BRACE
  | VARIABLE_SYMBOL
  | LIST_SEPARATOR
  | STATEMENT_TERMINATOR
  | NAMESPACE_SEPARATOR
  | SINGLE_QUOTE
  | DOUBLE_QUOTE
  | BACKTICK
  | AT
}

DOT                            = { "." }
OBJECT_ARROW                   = { "->" }
INCREMENT                      = { "++" }
DECREMENT                      = { "--" }
EXPONENTIATION                 = { "**" }
MULTIPLICATION                 = { "*" }
ADDITION                       = { "+" }
SUBTRACTION                    = { "-" }
BITWISE_NOT                    = { "~" }
LOGICAL_NOT                    = { "!" }
DIVISION                       = { "/" }
MODULUS                        = { "%" }
BITWISE_LEFT_SHIFT             = { "<<" }
BITWISE_RIGHT_SHIFT            = { ">>" }
LESS_THAN                      = { "<" }
GREATER_THAN                   = { ">" }
LESS_THAN_OR_EQUAL             = { "<=" }
GREATER_THAN_OR_EQUAL          = { ">=" }
EQUALITY                       = { "==" }
IDENTITY                       = { "===" }
INEQUALITY                     = { "!=" }
NON_IDENTITY                   = { "!==" }
BITWISE_XOR                    = { "^" }
BITWISE_OR                     = { "|" }
BITWISE_AND                    = { "&" }
LOGICAL_AND                    = { "&&" }
LOGICAL_OR                     = { "||" }
TERNARY_CONDITION              = { "?" }
TERNARY_SEPARATOR              = { ":" }
ASSIGNMENT                     = { "=" }
EXPONENTIATION_ASSIGNMENT      = { "**=" }
MULTIPLICATION_ASSIGNMENT      = { "*=" }
DIVISION_ASSIGNMENT            = { "/=" }
MODULUS_ASSIGNMENT             = { "%=" }
ADDITION_ASSIGNMENT            = { "+=" }
SUBTRACTION_ASSIGNMENT         = { "-=" }
CONCATENATION_ASSIGNMENT       = { ".=" }
BITWISE_LEFT_SHIFT_ASSIGNMENT  = { "<<=" }
BITWISE_RIGHT_SHIFT_ASSIGNMENT = { ">>=" }
BITWISE_AND_ASSIGNMENT         = { "&=" }
BITWISE_XOR_ASSIGNMENT         = { "^=" }
BITWISE_OR_ASSIGNMENT          = { "|=" }
NULL_COALESCING                = { "??" }
SCOPE_RESOLUTION               = { "::" }
ARRAY_ARROW                    = { "=>" }
SPACESHIP                      = { "<=>" }
ELLIPSIS                       = { "..." }
LEFT_SQUARE_BRACKET            = { "[" }
RIGHT_SQUARE_BRACKET           = { "]" }
LEFT_PARENTHESIS               = { "(" }
RIGHT_PARENTHESIS              = { ")" }
LEFT_CURLY_BRACE               = { "{" }
RIGHT_CURLY_BRACE              = { "}" }
VARIABLE_SYMBOL                = { "$" }
LIST_SEPARATOR                 = { "," }
STATEMENT_TERMINATOR           = { ";" }
NAMESPACE_SEPARATOR            = { "\\" }
SINGLE_QUOTE                   = { "'" }
DOUBLE_QUOTE                   = { "\"" }
BACKTICK                       = { "`" }
AT                             = { "@" }

// ***  SYNTATIC GRAMMAR *** //

// Basics

SCRIPT          = { SCRIPT_SECTION+ }
SCRIPT_SECTION  = { TEXT ~ START_TAG ~ SECTION_CONTENT ~ END_TAG? ~ TEXT }
SECTION_CONTENT = { (!END_TAG ~ ANY)* }
START_TAG       = { "<?php" | "<?=" }
END_TAG         = { "?>" }
TEXT            = { (!START_TAG ~ ANY)* }

// Variables

FUNCTION_STATIC_DECLARATION = { "static" ~ STATIC_VARIABLE_NAME_LIST ~ ";" }
STATIC_VARIABLE_NAME_LIST   = { STATIC_VARIABLE_DECLARATION ~ ("," ~ STATIC_VARIABLE_DECLARATION)* }
STATIC_VARIABLE_DECLARATION = { VARIABLE_NAME ~ FUNCTION_STATIC_INITIALIZER? }
FUNCTION_STATIC_INITIALIZER = { "=" ~ CONSTANT_EXPRESSION }
GLOBAL_DECLARATION          = { "global" ~ VARIABLE_NAME_LIST ~ ";" }
VARIABLE_NAME_LIST          = { SIMPLE_VARIABLE ~ ("," ~ SIMPLE_VARIABLE)* }

// Expressions

PRIMARY_EXPRESSION         = {
    VARIABLE
  | CLASS_CONSTANT_ACCESS_EXPRESSION
  | CONSTANT_ACCESS_EXPRESSION
  | LITERAL
  | ARRAY_CREATION_EXPRESSION
  | INTRINSIC
  | ANONYMOUS_FUNCTION_CREATION_EXPRESSION
  | OBJECT_CREATION_EXPRESSION
  | POSTFIX_INCREMENT_EXPRESSION
  | POSTFIX_DECREMENT_EXPRESSION
  | PREFIX_INCREMENT_EXPRESSION
  | PREFIX_DECREMENT_EXPRESSION
  | BYREF_ASSIGNMENT_EXPRESSION
  | SHELL_COMMAND_EXPRESSION
  | "(" ~ EXPRESSION ~ ")"
}
SIMPLE_VARIABLE            = {
    VARIABLE_NAME
  | "$" ~ (VARIABLE_NAME | "{" ~ EXPRESSION ~ "}")
}
DEREFERENCABLE_EXPRESSION  = {
    VARIABLE
  | "(" ~ EXPRESSION ~ ")"
  | ARRAY_CREATION_EXPRESSION
  | STRING_LITERAL
}
CALLABLE_EXPRESSION        = {
    CALLABLE_VARIABLE
  | "(" ~ EXPRESSION ~ ")"
  | ARRAY_CREATION_EXPRESSION
  | STRING_LITERAL
}
CALLABLE_VARIABLE          = {
    SIMPLE_VARIABLE
  | SUBSCRIPT_EXPRESSION
  | MEMBER_CALL_EXPRESSION
  | SCOPED_CALL_EXPRESSION
  | FUNCTION_CALL_EXPRESSION
}
VARIABLE                   = { CALLABLE_VARIABLE | SCOPED_PROPERTY_ACCESS_EXPRESSION | MEMBER_ACCESS_EXPRESSION }
CONSTANT_ACCESS_EXPRESSION = { QUALIFIED_NAME }
LITERAL                    = { INTEGER_LITERAL | FLOATING_LITERAL | STRING_LITERAL }
INTRINSIC                  = { EMPTY_INTRINSIC | EVAL_INTRINSIC | EXIT_INTRINSIC | ISSET_INTRINSIC }
EMPTY_INTRINSIC            = { "empty" ~ "(" ~ EXPRESSION ~ ")" }
EVAL_INTRINSIC             = { "eval" ~ "(" ~ EXPRESSION ~ ")" }
EXIT_INTRINSIC             = {
    "exit" ~ ("(" ~ EXPRESSION? ~ ")")?
  | "die" ~ ("(" ~ EXPRESSION? ~ ")")?
}
ISSET_INTRINSIC            = { "isset" ~ "(" ~ VARIABLE_LIST ~ ","? ~ ")" }
VARIABLE_LIST              = { VARIABLE ~ ("," ~ VARIABLE)* }
// @TODO: We may need to define white space between keywords
ANONYMOUS_FUNCTION_CREATION_EXPRESSION =  { "static"? ~ "function" ~ "&"? ~ "(" ~ PARAMETER_DECLARATION_LIST? ~ ")" ~ ANONYMOUS_FUNCTION_USE_CLAUSE? ~ RETURN_TYPE? ~ COMPOUND_STATEMENT }
ANONYMOUS_FUNCTION_USE_CLAUSE          =  { "use" ~ "(" ~ USE_VARIABLE_NAME_LIST ~ ")" }
USE_VARIABLE_NAME_LIST                 =  { "&"? ~ VARIABLE_NAME ~ ("," ~ "&"? ~ VARIABLE_NAME)* }
OBJECT_CREATION_EXPRESSION             =  {
    "new" ~ CLASS_TYPE_DESIGNATOR ~ ("(" ~ ARGUMENT_EXPRESSION_LIST? ~ ")")?
  | "new" ~ "class" ~ ("(" ~ ARGUMENT_EXPRESSION_LIST? ~ ")")? ~ CLASS_BASE_CLAUSE? ~ CLASS_INTERFACE_CLAUSE? ~ "{" ~ CLASS_MEMBER_DECLARATIONS? ~ "}"
}
CLASS_TYPE_DESIGNATOR                  = _{ QUALIFIED_NAME | NEW_VARIABLE }
NEW_VARIABLE                           =  { NEW_VARIABLE_BASE ~ NEW_VARIABLE_SUFFIX* }
NEW_VARIABLE_BASE                      = _{
    SIMPLE_VARIABLE
  | QUALIFIED_NAME ~ "::" ~ SIMPLE_VARIABLE
  | RELATIVE_SCOPE ~ "::" ~ SIMPLE_VARIABLE
}
NEW_VARIABLE_SUFFIX                    = _{
    "[" ~ EXPRESSION? ~ "]"
  | "{" ~ EXPRESSION ~ "}"
  | "->" ~ MEMBER_NAME
  | "::" ~ SIMPLE_VARIABLE
}
ARRAY_INITIALIZER_LIST                 =  { ARRAY_ELEMENT_INITIALIZER ~ ("," ~ ARRAY_ELEMENT_INITIALIZER)* }
ARRAY_ELEMENT_INITIALIZER              = _{
    "&"? ~ ELEMENT_VALUE
  | ELEMENT_KEY ~ "=>" ~ "&"? ~ ELEMENT_VALUE
}
ELEMENT_KEY                            =  { EXPRESSION }
ELEMENT_VALUE                          =  { EXPRESSION }
SUBSCRIPT_EXPRESSION                   =  {
    DEREFERENCABLE_EXPRESSION ~ "[" ~ EXPRESSION? ~ "]"
  | DEREFERENCABLE_EXPRESSION ~ "{" ~ EXPRESSION ~ "}"
}
FUNCTION_CALL_EXPRESSION               =  { (QUALIFIED_NAME | CALLABLE_EXPRESSION) ~ "(" ~ (ARGUMENT_EXPRESSION_LIST? | ARGUMENT_EXPRESSION_LIST ~ ",") ~ ")" }
ARGUMENT_EXPRESSION_LIST               =  { ARGUMENT_EXPRESSION ~ ("," ~ ARGUMENT_EXPRESSION)* }
ARGUMENT_EXPRESSION                    =  { VARIADIC_UNPACKING | EXPRESSION }
VARIADIC_UNPACKING                     =  { "..." ~ EXPRESSION }
MEMBER_ACCESS_EXPRESSION               =  { DEREFERENCABLE_EXPRESSION ~ "->" ~ MEMBER_NAME }
MEMBER_NAME                            =  { NAME | SIMPLE_VARIABLE | "{" ~ EXPRESSION ~ "}" }
MEMBER_CALL_EXPRESSION                 =  { DEREFERENCABLE_EXPRESSION ~ "->" ~ MEMBER_NAME ~ "(" ~ (ARGUMENT_EXPRESSION_LIST? | ARGUMENT_EXPRESSION_LIST ~ ",") ~ ")" }
POSTFIX_INCREMENT_EXPRESSION           =  { VARIABLE ~ "++" }
POSTFIX_DECREMENT_EXPRESSION           =  { VARIABLE ~ "--" }
PREFIX_INCREMENT_EXPRESSION            =  { "++" ~ VARIABLE }
PREFIX_DECREMENT_EXPRESSION            =  { "--" ~ VARIABLE }
SHELL_COMMAND_EXPRESSION               =  { "`" ~ DQ_CHAR_SEQUENCE? ~ "`" }
SCOPED_PROPERTY_ACCESS_EXPRESSION      =  { SCOPE_RESOLUTION_QUALIFIER ~ "::" ~ SIMPLE_VARIABLE }
SCOPED_CALL_EXPRESSION                 =  { SCOPE_RESOLUTION_QUALIFIER ~ "::" ~ MEMBER_NAME ~ "(" ~ (ARGUMENT_EXPRESSION_LIST? | ARGUMENT_EXPRESSION_LIST ~ ",") ~ ")" }
CLASS_CONSTANT_ACCESS_EXPRESSION       =  { SCOPE_RESOLUTION_QUALIFIER ~ "::" ~ NAME }
SCOPE_RESOLUTION_QUALIFIER             =  { RELATIVE_SCOPE | QUALIFIED_NAME | DEREFERENCABLE_EXPRESSION }
RELATIVE_SCOPE                         =  { "self" | "parent" | "static" }
CLONE_EXPRESSION                       =  { PRIMARY_EXPRESSION | "clone" ~ PRIMARY_EXPRESSION }
EXPONENTIATION_EXPRESSION              =  { CLONE_EXPRESSION | CLONE_EXPRESSION ~ "**" ~ EXPONENTIATION_EXPRESSION }
UNARY_EXPRESSION                       =  {
    EXPONENTIATION_EXPRESSION
  | UNARY_OPERATOR_EXPRESSION
  | ERROR_CONTROL_EXPRESSION
  | CAST_EXPRESSION
}
UNARY_OPERATOR_EXPRESSION              =  { UNARY_OPERATOR ~ UNARY_EXPRESSION }
UNARY_OPERATOR                         =  { "+" | "-" | "~" }
ERROR_CONTROL_EXPRESSION               =  { "@" ~ UNARY_EXPRESSION }
CAST_EXPRESSION                        =  { "(" ~ CAST_TYPE ~ ")" ~ UNARY_EXPRESSION }
CAST_TYPE                              =  { "array" | "binary" | "bool" | "boolean" | "double" | "int" | "integer" | "float" | "object" | "real" | "string" | "unset" }
INSTANCEOF_EXPRESSION                  =  { UNARY_EXPRESSION | INSTANCEOF_SUBJECT ~ "instanceof" ~ CLASS_TYPE_DESIGNATOR }
INSTANCEOF_SUBJECT                     =  { INSTANCEOF_EXPRESSION }
LOGICAL_NOT_EXPRESSION                 =  { INSTANCEOF_EXPRESSION | "!" ~ INSTANCEOF_EXPRESSION }
MULTIPLICATIVE_EXPRESSION              =  { LOGICAL_NOT_EXPRESSION ~ (("*" | "/" | "%") ~ LOGICAL_NOT_EXPRESSION)* }
ADDITIVE_EXPRESSION                    =  { MULTIPLICATIVE_EXPRESSION ~ (("+" | "-" | ".") ~ MULTIPLICATIVE_EXPRESSION)* }
SHIFT_EXPRESSION                       =  { ADDITIVE_EXPRESSION ~ (("<<" | ">>") ~ ADDITIVE_EXPRESSION)* }
RELATIONAL_EXPRESSION                  =  { SHIFT_EXPRESSION ~ (("<" | ">" | "<=" | ">=" | "<=>") ~ SHIFT_EXPRESSION)* }
EQUALITY_EXPRESSION                    =  { RELATIONAL_EXPRESSION ~ (("==" | "!=" | "<>" | "===" | "!==") ~ RELATIONAL_EXPRESSION)* }
BITWISE_AND_EXPRESSION                 =  { EQUALITY_EXPRESSION ~ ("&" ~ EQUALITY_EXPRESSION)* }
BITWISE_EXC_OR_EXPRESSION              =  { BITWISE_AND_EXPRESSION ~ ("^" ~ BITWISE_AND_EXPRESSION)* }
BITWISE_INC_OR_EXPRESSION              =  { BITWISE_EXC_OR_EXPRESSION ~ ("|" ~ BITWISE_EXC_OR_EXPRESSION)* }
LOGICAL_AND_EXPRESSION_1               =  { BITWISE_INC_OR_EXPRESSION ~ ("&&" ~ BITWISE_INC_OR_EXPRESSION)* }
LOGICAL_INC_OR_EXPRESSION_1            =  { LOGICAL_AND_EXPRESSION_1 ~ ("||" ~ LOGICAL_AND_EXPRESSION_1)* }
COALESCE_EXPRESSION                    =  { LOGICAL_INC_OR_EXPRESSION_1 ~ ("??" ~ COALESCE_EXPRESSION)? }
CONDITIONAL_EXPRESSION                 =  { COALESCE_EXPRESSION ~ ("?" ~ EXPRESSION? ~ ":" ~ COALESCE_EXPRESSION)* }
ASSIGNMENT_EXPRESSION                  =  {
    CONDITIONAL_EXPRESSION
  | SIMPLE_ASSIGNMENT_EXPRESSION
  | COMPOUND_ASSIGNMENT_EXPRESSION
}
SIMPLE_ASSIGNMENT_EXPRESSION           =  { (VARIABLE | LIST_INTRINSIC) ~ "=" ~ ASSIGNMENT_EXPRESSION }
LIST_INTRINSIC                         =  { "list" ~ "(" ~ LIST_EXPRESSION_LIST ~ ")" }
LIST_EXPRESSION_LIST                   =  { UNKEYED_LIST_EXPRESSION_LIST | KEYED_LIST_EXPRESSION_LIST ~ ","? }
UNKEYED_LIST_EXPRESSION_LIST           =  { (LIST_OR_VARIABLE | ",") ~ ("," ~ LIST_OR_VARIABLE?)* }
KEYED_LIST_EXPRESSION_LIST             =  { EXPRESSION ~ "=>" ~ LIST_OR_VARIABLE ~ ("," ~ EXPRESSION ~ "=>" ~ LIST_OR_VARIABLE)* }
LIST_OR_VARIABLE                       =  { LIST_INTRINSIC | "&"? ~ VARIABLE }
BYREF_ASSIGNMENT_EXPRESSION            =  { VARIABLE ~ "=" ~ "&" ~ VARIABLE }
COMPOUND_ASSIGNMENT_EXPRESSION         =  { VARIABLE ~ COMPOUND_ASSIGNMENT_OPERATOR ~ ASSIGNMENT_EXPRESSION }
COMPOUND_ASSIGNMENT_OPERATOR           =  { "**=" | "*=" | "/=" | "%=" | "+=" | "-=" | ".=" | "<<=" | ">>=" | "&=" | "^=" | "|=" }
YIELD_FROM_EXPRESSION                  =  { "yield from" ~ ASSIGNMENT_EXPRESSION }
YIELD_EXPRESSION                       =  { "yield" ~ ((YIELD_FROM_EXPRESSION ~ "=>")? ~ YIELD_EXPRESSION)? | YIELD_FROM_EXPRESSION }
PRINT_EXPRESSION                       =  { YIELD_EXPRESSION | "print" ~ PRINT_EXPRESSION }
LOGICAL_AND_EXPRESSION_2               =  { PRINT_EXPRESSION ~ ("and" ~ YIELD_EXPRESSION)* }
LOGICAL_EXC_OR_EXPRESSION              =  { LOGICAL_AND_EXPRESSION_2 ~ ("xor" ~ LOGICAL_AND_EXPRESSION_2)* }
LOGICAL_INC_OR_EXPRESSION_2            =  { LOGICAL_EXC_OR_EXPRESSION ~ ("or" ~ LOGICAL_EXC_OR_EXPRESSION)* }
EXPRESSION                             =  {
    LOGICAL_INC_OR_EXPRESSION_2
  | INCLUDE_EXPRESSION
  | INCLUDE_ONCE_EXPRESSION
  | REQUIRE_EXPRESSION
  | REQUIRE_ONCE_EXPRESSION
}
INCLUDE_EXPRESSION                     =  { "include" ~ EXPRESSION }
INCLUDE_ONCE_EXPRESSION                =  { "include_once" ~ EXPRESSION }
REQUIRE_EXPRESSION                     =  { "require" ~ EXPRESSION }
REQUIRE_ONCE_EXPRESSION                =  { "require_once" ~ EXPRESSION }
CONSTANT_EXPRESSION                    =  { EXPRESSION }

// Statements

