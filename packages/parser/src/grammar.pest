// Root

FILE = { SOI ~ SCRIPT ~ EOI }

// ***  LEXICAL GRAMMAR *** //

// Input

INPUT_FILE       =  { INPUT_ELEMENT+ }
INPUT_ELEMENT    = _{ COMMENT | WHITE_SPACE | TOKEN }
INPUT_CHARACTERS = _{ INPUT_CHARACTER+ }
INPUT_CHARACTER  = _{ (!NEW_LINE ~ ANY) }

// Comments

COMMENT             = _{ SINGLE_LINE_COMMENT | DELIMITED_COMMENT }
SINGLE_LINE_COMMENT = _{ "//" ~ INPUT_CHARACTERS? }
DELIMITED_COMMENT   = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Whitespace

WHITE_SPACE           = _{ WHITE_SPACE_CHARACTER+ }
WHITE_SPACE_CHARACTER = _{ NEW_LINE | " " | "\t" }
NEW_LINE              = _{ "\r" | "\n" | "\r\n" }

// Tokens

TOKEN = {
    VARIABLE_NAME
  | NAME
  | KEYWORD
  | INTEGER_LITERAL
  | FLOATING_LITERAL
  | STRING_LITERAL
  | OPERATOR_OR_PUNCTUATOR
}

// Names

VARIABLE_NAME              =  { "$" ~ NAME }
NAMESPACE_NAME             =  { NAME ~ ("\\" ~ NAME)* }
NAMESPACE_NAME_AS_A_PREFIX =  {
    "\\"
  | ("\\"? ~ NAMESPACE_NAME ~ "\\")
  | (KEYWORD_NAMESPACE ~ "\\")
  | (KEYWORD_NAMESPACE ~ "\\" ~ NAMESPACE_NAME ~ "\\")
}
QUALIFIED_NAME             =  { NAMESPACE_NAME_AS_A_PREFIX? ~ NAME }
NAME                       =  { NAME_NONDIGIT ~ (NAME_NONDIGIT | DIGIT)* }
NAME_NONDIGIT              = _{ NONDIGIT | '\u{80}'..'\u{FF}' }
NONDIGIT                   = _{ "_" | ASCII_ALPHA }

// Keywords

KEYWORD              = {
    KEYWORD_ABSTRACT
  | KEYWORD_AND
  | KEYWORD_ARRAY
  | KEYWORD_AS
  | KEYWORD_BREAK
  | KEYWORD_CALLABLE
  | KEYWORD_CASE
  | KEYWORD_CATCH
  | KEYWORD_CLASS
  | KEYWORD_CLONE
  | KEYWORD_CONST
  | KEYWORD_CONTINUE
  | KEYWORD_DECLARE
  | KEYWORD_DEFAULT
  | KEYWORD_DIE
  | KEYWORD_DO
  | KEYWORD_ECHO
  | KEYWORD_ELSE
  | KEYWORD_ELSEIF
  | KEYWORD_EMPTY
  | KEYWORD_ENDDECLARE
  | KEYWORD_ENDFOR
  | KEYWORD_ENDFOREACH
  | KEYWORD_ENDIF
  | KEYWORD_ENDSWITCH
  | KEYWORD_ENDWHILE
  | KEYWORD_EVAL
  | KEYWORD_EXIT
  | KEYWORD_EXTENDS
  | KEYWORD_FINAL
  | KEYWORD_FINALLY
  | KEYWORD_FOR
  | KEYWORD_FOREACH
  | KEYWORD_FUNCTION
  | KEYWORD_GLOBAL
  | KEYWORD_GOTO
  | KEYWORD_IF
  | KEYWORD_IMPLEMENTS
  | KEYWORD_INCLUDE
  | KEYWORD_INCLUDE_ONCE
  | KEYWORD_INSTANCEOF
  | KEYWORD_INSTEADOF
  | KEYWORD_INTERFACE
  | KEYWORD_ISSET
  | KEYWORD_LIST
  | KEYWORD_NAMESPACE
  | KEYWORD_NEW
  | KEYWORD_OR
  | KEYWORD_PRINT
  | KEYWORD_PRIVATE
  | KEYWORD_PROTECTED
  | KEYWORD_PUBLIC
  | KEYWORD_REQUIRE
  | KEYWORD_REQUIRE_ONCE
  | KEYWORD_RETURN
  | KEYWORD_STATIC
  | KEYWORD_SWITCH
  | KEYWORD_THROW
  | KEYWORD_TRAIT
  | KEYWORD_TRY
  | KEYWORD_UNSET
  | KEYWORD_USE
  | KEYWORD_VAR
  | KEYWORD_WHILE
  | KEYWORD_XOR
  | KEYWORD_YIELD
  | KEYWORD_YIELD_FROM
}
KEYWORD_ABSTRACT     = { "abstract" }
KEYWORD_AND          = { "and" }
KEYWORD_ARRAY        = { "array" }
KEYWORD_AS           = { "as" }
KEYWORD_BREAK        = { "break" }
KEYWORD_CALLABLE     = { "callable" }
KEYWORD_CASE         = { "case" }
KEYWORD_CATCH        = { "catch" }
KEYWORD_CLASS        = { "class" }
KEYWORD_CLONE        = { "clone" }
KEYWORD_CONST        = { "const" }
KEYWORD_CONTINUE     = { "continue" }
KEYWORD_DECLARE      = { "declare" }
KEYWORD_DEFAULT      = { "default" }
KEYWORD_DIE          = { "die" }
KEYWORD_DO           = { "do" }
KEYWORD_ECHO         = { "echo" }
KEYWORD_ELSE         = { "else" }
KEYWORD_ELSEIF       = { "elseif" }
KEYWORD_EMPTY        = { "empty" }
KEYWORD_ENDDECLARE   = { "enddeclare" }
KEYWORD_ENDFOR       = { "endfor" }
KEYWORD_ENDFOREACH   = { "endforeach" }
KEYWORD_ENDIF        = { "endif" }
KEYWORD_ENDSWITCH    = { "endswitch" }
KEYWORD_ENDWHILE     = { "endwhile" }
KEYWORD_EVAL         = { "eval" }
KEYWORD_EXIT         = { "exit" }
KEYWORD_EXTENDS      = { "extends" }
KEYWORD_FINAL        = { "final" }
KEYWORD_FINALLY      = { "finally" }
KEYWORD_FOR          = { "for" }
KEYWORD_FOREACH      = { "foreach" }
KEYWORD_FUNCTION     = { "function" }
KEYWORD_GLOBAL       = { "global" }
KEYWORD_GOTO         = { "goto" }
KEYWORD_IF           = { "if" }
KEYWORD_IMPLEMENTS   = { "implements" }
KEYWORD_INCLUDE      = { "include" }
KEYWORD_INCLUDE_ONCE = { "include_once" }
KEYWORD_INSTANCEOF   = { "instanceof" }
KEYWORD_INSTEADOF    = { "insteadof" }
KEYWORD_INTERFACE    = { "interface" }
KEYWORD_ISSET        = { "isset" }
KEYWORD_LIST         = { "list" }
KEYWORD_NAMESPACE    = { "namespace" }
KEYWORD_NEW          = { "new" }
KEYWORD_OR           = { "or" }
KEYWORD_PRINT        = { "print" }
KEYWORD_PRIVATE      = { "private" }
KEYWORD_PROTECTED    = { "protected" }
KEYWORD_PUBLIC       = { "public" }
KEYWORD_REQUIRE      = { "require" }
KEYWORD_REQUIRE_ONCE = { "require_once" }
KEYWORD_RETURN       = { "return" }
KEYWORD_STATIC       = { "static" }
KEYWORD_SWITCH       = { "switch" }
KEYWORD_THROW        = { "throw" }
KEYWORD_TRAIT        = { "trait" }
KEYWORD_TRY          = { "try" }
KEYWORD_UNSET        = { "unset" }
KEYWORD_USE          = { "use" }
KEYWORD_VAR          = { "var" }
KEYWORD_WHILE        = { "while" }
KEYWORD_XOR          = { "xor" }
KEYWORD_YIELD        = { "yield" }
KEYWORD_YIELD_FROM   = { "yield from" }

// Integer Literal

INTEGER_LITERAL     = {
    DECIMAL_LITERAL
  | OCTAL_LITERAL
  | HEXADECIMAL_LITERAL
  | BINARY_LITERAL
}
DECIMAL_LITERAL     = { NONZERO_DIGIT ~ DIGIT* }
OCTAL_LITERAL       = { "0" ~ OCTAL_DIGIT+ }
HEXADECIMAL_LITERAL = { "0" ~ ^"x" ~ HEXADECIMAL_DIGIT+ }
BINARY_LITERAL      = { "0" ~ ^"b" ~ BINARY_DIGIT+ }

DIGIT             = _{ ASCII_DIGIT }
NONZERO_DIGIT     = _{ ASCII_NONZERO_DIGIT }
OCTAL_DIGIT       = _{ ASCII_OCT_DIGIT }
HEXADECIMAL_DIGIT = _{ ASCII_HEX_DIGIT }
BINARY_DIGIT      = _{ ASCII_BIN_DIGIT }

// Floating Literal

FLOATING_LITERAL   =  { (FRACTIONAL_LITERAL ~ EXPONENT_PART?) | (DIGIT+ ~ EXPONENT_PART) }
FRACTIONAL_LITERAL =  { (DIGIT* ~ "." ~ DIGIT+) | (DIGIT+ ~ ".") }
EXPONENT_PART      = _{ ^"e" ~ SIGN? ~ DIGIT+ }
SIGN               =  { SIGN_PLUS | SIGN_MINUS }
SIGN_PLUS          =  { "+" }
SIGN_MINUS         =  { "-" }

// String Literal

STRING_LITERAL                            =  {
    SINGLE_QUOTED_STRING_LITERAL
  | DOUBLE_QUOTED_STRING_LITERAL
  | HEREDOC_STRING_LITERAL
  | NOWDOC_STRING_LITERAL
}
SINGLE_QUOTED_STRING_LITERAL              =  { BINARY_PREFIX? ~ "'" ~ SINGLE_QUOTED_CHARACTER* ~ "'" }
SINGLE_QUOTED_CHARACTER                   =  { SINGLE_QUOTED_ESCAPE_SEQUENCE | !("'" | "\\") ~ ANY }
SINGLE_QUOTED_ESCAPE_SEQUENCE             =  { "\\'" | "\\\\" }
BINARY_PREFIX                             =  { ^"b" }
DOUBLE_QUOTED_STRING_LITERAL              =  { BINARY_PREFIX? ~ "\"" ~ DOUBLE_QUOTED_CHARACTER* ~ "\"" }
DOUBLE_QUOTED_CHARACTER                   =  {
    DOUBLE_QUOTED_ESCAPE_SEQUENCE
  | !("\"" | "\\") ~ ANY
  | "\\" ~ !("\"" | "\\" | "$" | "e" | "f" | "n" | "r" | "t" | "v" | ^"x" | OCTAL_DIGIT) ~ ANY
}
DOUBLE_QUOTED_ESCAPE_SEQUENCE             =  {
    DOUBLE_QUOTED_SIMPLE_ESCAPE_SEQUENCE
  | DOUBLE_QUOTED_OCTAL_ESCAPE_SEQUENCE
  | DOUBLE_QUOTED_HEXADECIMAL_ESCAPE_SEQUENCE
  | DOUBLE_QUOTED_UNICODE_ESCAPE_SEQUENCE
}
DOUBLE_QUOTED_SIMPLE_ESCAPE_SEQUENCE      = _{ "\\\"" | "\\\\" | "\\$" | "\\e" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v" }
DOUBLE_QUOTED_OCTAL_ESCAPE_SEQUENCE       = _{ "\\" ~ OCTAL_DIGIT{1, 3} }
DOUBLE_QUOTED_HEXADECIMAL_ESCAPE_SEQUENCE = _{ "\\" ~ ^"x" ~ HEXADECIMAL_DIGIT{1, 2} }
DOUBLE_QUOTED_UNICODE_ESCAPE_SEQUENCE     = _{ "\\u" ~ "{" ~ HEXADECIMAL_DIGIT+ ~ "}" }
STRING_VARIABLE                           =  {
    VARIABLE_NAME ~ OFFSET_OR_PROPERTY?
  | "{$" ~ EXPRESSION ~ "}"
}
OFFSET_OR_PROPERTY                        =  { OFFSET_IN_STRING | PROPERTY_IN_STRING }
OFFSET_IN_STRING                          =  { "[" ~ (NAME | VARIABLE_NAME | INTEGER_LITERAL) ~ "]" }
PROPERTY_IN_STRING                        =  { "->" ~ NAME }
HEREDOC_STRING_LITERAL                    =  { BINARY_PREFIX? ~ "<<<" ~ HEREDOC_START_IDENTIFIER ~ NEW_LINE ~ HEREDOC_BODY? ~ HEREDOC_END_IDENTIFIER ~ ";"? ~ NEW_LINE }
HEREDOC_START_IDENTIFIER                  =  { NAME | ("\"") ~ NAME ~ ("\"") }
HEREDOC_END_IDENTIFIER                    =  { NAME }
HEREDOC_BODY                              =  { HEREDOC_CHAR* ~ NEW_LINE }
HEREDOC_CHAR                              = _{
    HEREDOC_ESCAPE_SEQUENCE
  | !"\\" ~ ANY
  | "\\" ~ !("\\" | "$" | "e" | "f" | "n" | "r" | "t" | "v" | ^"x" | OCTAL_DIGIT) ~ ANY
}
HEREDOC_ESCAPE_SEQUENCE                   =  {
    HEREDOC_SIMPLE_ESCAPE_SEQUENCE
  | DOUBLE_QUOTED_OCTAL_ESCAPE_SEQUENCE
  | DOUBLE_QUOTED_HEXADECIMAL_ESCAPE_SEQUENCE
  | DOUBLE_QUOTED_UNICODE_ESCAPE_SEQUENCE
}
HEREDOC_SIMPLE_ESCAPE_SEQUENCE            = _{ "\\\\" | "\\$" | "\\e" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v" }
NOWDOC_STRING_LITERAL                     =  { BINARY_PREFIX? ~ "<<<" ~ "'" ~ NAME ~ "'" ~ NEW_LINE ~ HEREDOC_BODY? ~ NAME ~ ";"? ~ NEW_LINE }

// Operators and Punctuators

OPERATOR_OR_PUNCTUATOR                  = _{ OPERATOR | PUNCTUATOR }
OPERATOR                                = _{
    OPERATOR_DOT
  | OPERATOR_OBJECT
  | OPERATOR_INCREMENT
  | OPERATOR_DECREMENT
  | OPERATOR_EXPONENTIATION
  | OPERATOR_MULTIPLICATION
  | OPERATOR_ADDITION
  | OPERATOR_SUBTRACTION
  | OPERATOR_BITWISE_NOT
  | OPERATOR_LOGICAL_NOT
  | OPERATOR_DIVISION
  | OPERATOR_MODULUS
  | OPERATOR_BITWISE_LEFT_SHIFT
  | OPERATOR_BITWISE_RIGHT_SHIFT
  | OPERATOR_LESS_THAN
  | OPERATOR_GREATER_THAN
  | OPERATOR_LESS_THAN_OR_EQUAL
  | OPERATOR_GREATER_THAN_OR_EQUAL
  | OPERATOR_EQUALITY
  | OPERATOR_IDENTITY
  | OPERATOR_INEQUALITY
  | OPERATOR_NON_IDENTITY
  | OPERATOR_BITWISE_XOR
  | OPERATOR_BITWISE_OR
  | OPERATOR_BITWISE_AND
  | OPERATOR_LOGICAL_AND
  | OPERATOR_LOGICAL_OR
  | OPERATOR_TERNARY_CONDITION
  | OPERATOR_TERNARY_SEPARATOR
  | OPERATOR_ASSIGNMENT
  | OPERATOR_EXPONENTIATION_ASSIGNMENT
  | OPERATOR_MULTIPLICATION_ASSIGNMENT
  | OPERATOR_DIVISION_ASSIGNMENT
  | OPERATOR_MODULUS_ASSIGNMENT
  | OPERATOR_ADDITION_ASSIGNMENT
  | OPERATOR_SUBTRACTION_ASSIGNMENT
  | OPERATOR_CONCATENATION_ASSIGNMENT
  | OPERATOR_BITWISE_LEFT_SHIFT_ASSIGNMENT
  | OPERATOR_BITWISE_RIGHT_SHIFT_ASSIGNMENT
  | OPERATOR_BITWISE_AND_ASSIGNMENT
  | OPERATOR_BITWISE_XOR_ASSIGNMENT
  | OPERATOR_BITWISE_OR_ASSIGNMENT
  | OPERATOR_NULL_COALESCING
  | OPERATOR_SCOPE_RESOLUTION
  | OPERATOR_ARRAY_ASSOCIATION
  | OPERATOR_SPACESHIP
  | OPERATOR_ELLIPSIS
}
OPERATOR_DOT                            =  { "." }
OPERATOR_OBJECT                         =  { "->" }
OPERATOR_INCREMENT                      =  { "++" }
OPERATOR_DECREMENT                      =  { "--" }
OPERATOR_EXPONENTIATION                 =  { "**" }
OPERATOR_MULTIPLICATION                 =  { "*" }
OPERATOR_ADDITION                       =  { "+" }
OPERATOR_SUBTRACTION                    =  { "-" }
OPERATOR_BITWISE_NOT                    =  { "~" }
OPERATOR_LOGICAL_NOT                    =  { "!" }
OPERATOR_DIVISION                       =  { "/" }
OPERATOR_MODULUS                        =  { "%" }
OPERATOR_BITWISE_LEFT_SHIFT             =  { "<<" }
OPERATOR_BITWISE_RIGHT_SHIFT            =  { ">>" }
OPERATOR_LESS_THAN                      =  { "<" }
OPERATOR_GREATER_THAN                   =  { ">" }
OPERATOR_LESS_THAN_OR_EQUAL             =  { "<=" }
OPERATOR_GREATER_THAN_OR_EQUAL          =  { ">=" }
OPERATOR_EQUALITY                       =  { "==" }
OPERATOR_IDENTITY                       =  { "===" }
OPERATOR_INEQUALITY                     =  { "!=" }
OPERATOR_NON_IDENTITY                   =  { "!==" }
OPERATOR_BITWISE_XOR                    =  { "^" }
OPERATOR_BITWISE_OR                     =  { "|" }
OPERATOR_BITWISE_AND                    =  { "&" }
OPERATOR_LOGICAL_AND                    =  { "&&" }
OPERATOR_LOGICAL_OR                     =  { "||" }
OPERATOR_TERNARY_CONDITION              =  { "?" }
OPERATOR_TERNARY_SEPARATOR              =  { ":" }
OPERATOR_ASSIGNMENT                     =  { "=" }
OPERATOR_EXPONENTIATION_ASSIGNMENT      =  { "**=" }
OPERATOR_MULTIPLICATION_ASSIGNMENT      =  { "*=" }
OPERATOR_DIVISION_ASSIGNMENT            =  { "/=" }
OPERATOR_MODULUS_ASSIGNMENT             =  { "%=" }
OPERATOR_ADDITION_ASSIGNMENT            =  { "+=" }
OPERATOR_SUBTRACTION_ASSIGNMENT         =  { "-=" }
OPERATOR_CONCATENATION_ASSIGNMENT       =  { ".=" }
OPERATOR_BITWISE_LEFT_SHIFT_ASSIGNMENT  =  { "<<=" }
OPERATOR_BITWISE_RIGHT_SHIFT_ASSIGNMENT =  { ">>=" }
OPERATOR_BITWISE_AND_ASSIGNMENT         =  { "&=" }
OPERATOR_BITWISE_XOR_ASSIGNMENT         =  { "^=" }
OPERATOR_BITWISE_OR_ASSIGNMENT          =  { "|=" }
OPERATOR_NULL_COALESCING                =  { "??" }
OPERATOR_SCOPE_RESOLUTION               =  { "::" }
OPERATOR_ARRAY_ASSOCIATION              =  { "=>" }
OPERATOR_SPACESHIP                      =  { "<=>" }
OPERATOR_ELLIPSIS                       =  { "..." }
PUNCTUATOR                              = _{
    LEFT_SQUARE_BRACKET
  | RIGHT_SQUARE_BRACKET
  | LEFT_PARENTHESIS
  | RIGHT_PARENTHESIS
  | LEFT_CURLY_BRACE
  | RIGHT_CURLY_BRACE
  | VARIABLE_SYMBOL
  | LIST_SEPARATOR
  | STATEMENT_TERMINATOR
  | NAMESPACE_SEPARATOR
}
LEFT_SQUARE_BRACKET                     =  { "[" }
RIGHT_SQUARE_BRACKET                    =  { "]" }
LEFT_PARENTHESIS                        =  { "(" }
RIGHT_PARENTHESIS                       =  { ")" }
LEFT_CURLY_BRACE                        =  { "{" }
RIGHT_CURLY_BRACE                       =  { "}" }
VARIABLE_SYMBOL                         =  { "$" }
LIST_SEPARATOR                          =  { "," }
STATEMENT_TERMINATOR                    =  { ";" }
NAMESPACE_SEPARATOR                     =  { "\\" }

// ***  SYNTATIC GRAMMAR *** //

// Basics

SCRIPT          = { SCRIPT_SECTION+ }
SCRIPT_SECTION  = { TEXT ~ START_TAG ~ SECTION_CONTENT ~ END_TAG? ~ TEXT }
SECTION_CONTENT = { (!END_TAG ~ ANY)* }
START_TAG       = { "<?php" | "<?=" }
END_TAG         = { "?>" }
TEXT            = { (!START_TAG ~ ANY)* }

// Variables

FUNCTION_STATIC_DECLARATION = { KEYWORD_STATIC ~ STATIC_VARIABLE_NAME_LIST ~ STATEMENT_TERMINATOR }
STATIC_VARIABLE_NAME_LIST   = { STATIC_VARIABLE_DECLARATION ~ (LIST_SEPARATOR ~ STATIC_VARIABLE_DECLARATION)* }
STATIC_VARIABLE_DECLARATION = { VARIABLE_NAME ~ FUNCTION_STATIC_INITIALIZER? }
FUNCTION_STATIC_INITIALIZER = { OPERATOR_ASSIGNMENT ~ CONSTANT_EXPRESSION }
GLOBAL_DECLARATION          = { KEYWORD_GLOBAL ~ VARIABLE_NAME_LIST ~ STATEMENT_TERMINATOR }
VARIABLE_NAME_LIST          = { SIMPLE_VARIABLE ~ (LIST_SEPARATOR ~ SIMPLE_VARIABLE)* }

// Expressions

// @TODO: Review expressions, they have been generated with AI.
PRIMARY_EXPRESSION         = {
    VARIABLE
  | CLASS_CONSTANT_ACCESS_EXPRESSION
  | CONSTANT_ACCESS_EXPRESSION
  | LITERAL
  | ARRAY_CREATION_EXPRESSION
  | INTRINSIC
  | ANONYMOUS_FUNCTION_CREATION_EXPRESSION
  | OBJECT_CREATION_EXPRESSION
  | POSTFIX_INCREMENT_EXPRESSION
  | POSTFIX_DECREMENT_EXPRESSION
  | PREFIX_INCREMENT_EXPRESSION
  | PREFIX_DECREMENT_EXPRESSION
  | BYREF_ASSIGNMENT_EXPRESSION
  | SHELL_COMMAND_EXPRESSION
  | LEFT_PARENTHESIS ~ EXPRESSION ~ RIGHT_PARENTHESIS
}
SIMPLE_VARIABLE            = {
    VARIABLE_NAME
  | VARIABLE_SYMBOL ~ VARIABLE_NAME
  | VARIABLE_SYMBOL ~ LEFT_CURLY_BRACE ~ EXPRESSION ~ RIGHT_CURLY_BRACE
}
DEREFERENCABLE_EXPRESSION  = {
    VARIABLE
  | LEFT_PARENTHESIS ~ EXPRESSION ~ RIGHT_PARENTHESIS
  | ARRAY_CREATION_EXPRESSION
  | STRING_LITERAL
}
CALLABLE_EXPRESSION        = {
    CALLABLE_VARIABLE
  | LEFT_PARENTHESIS ~ EXPRESSION ~ RIGHT_PARENTHESIS
  | ARRAY_CREATION_EXPRESSION
  | STRING_LITERAL
}
CALLABLE_VARIABLE          = {
    SIMPLE_VARIABLE
  | SUBSCRIPT_EXPRESSION
  | MEMBER_CALL_EXPRESSION
  | SCOPED_CALL_EXPRESSION
  | FUNCTION_CALL_EXPRESSION
}
VARIABLE                   = { CALLABLE_VARIABLE | SCOPED_PROPERTY_ACCESS_EXPRESSION | MEMBER_ACCESS_EXPRESSION }
CONSTANT_ACCESS_EXPRESSION = { QUALIFIED_NAME }
LITERAL                    = { INTEGER_LITERAL | FLOATING_LITERAL | STRING_LITERAL }
INTRINSIC                  = { EMPTY_INTRINSIC | EVAL_INTRINSIC | EXIT_INTRINSIC | ISSET_INTRINSIC }
EMPTY_INTRINSIC            = { KEYWORD_EMPTY ~ LEFT_PARENTHESIS ~ EXPRESSION ~ RIGHT_PARENTHESIS }
EVAL_INTRINSIC             = { KEYWORD_EVAL ~ LEFT_PARENTHESIS ~ EXPRESSION ~ RIGHT_PARENTHESIS }
EXIT_INTRINSIC             = {
    KEYWORD_EXIT ~ (LEFT_PARENTHESIS ~ EXPRESSION? ~ RIGHT_PARENTHESIS)?
  | KEYWORD_DIE ~ (LEFT_PARENTHESIS ~ EXPRESSION? ~ RIGHT_PARENTHESIS)?
}
ISSET_INTRINSIC            = { KEYWORD_ISSET ~ LEFT_PARENTHESIS ~ VARIABLE_LIST ~ LIST_SEPARATOR? ~ RIGHT_PARENTHESIS }
VARIABLE_LIST              = { VARIABLE ~ (LIST_SEPARATOR ~ VARIABLE)* }
// @TODO: We may need to define white space between keywords
ANONYMOUS_FUNCTION_CREATION_EXPRESSION =  { KEYWORD_STATIC? ~ KEYWORD_FUNCTION ~ OPERATOR_BITWISE_AND? ~ LEFT_PARENTHESIS ~ PARAMETER_DECLARATION_LIST? ~ RIGHT_PARENTHESIS ~ ANONYMOUS_FUNCTION_USE_CLAUSE? ~ RETURN_TYPE? ~ COMPOUND_STATEMENT }
ANONYMOUS_FUNCTION_USE_CLAUSE          =  { KEYWORD_USE ~ LEFT_PARENTHESIS ~ USE_VARIABLE_NAME_LIST ~ RIGHT_PARENTHESIS }
USE_VARIABLE_NAME_LIST                 =  { OPERATOR_BITWISE_AND? ~ VARIABLE_NAME ~ (LIST_SEPARATOR ~ OPERATOR_BITWISE_AND? ~ VARIABLE_NAME)* }
OBJECT_CREATION_EXPRESSION             =  {
    KEYWORD_NEW ~ CLASS_TYPE_DESIGNATOR ~ (LEFT_PARENTHESIS ~ ARGUMENT_EXPRESSION_LIST? ~ RIGHT_PARENTHESIS)?
  | KEYWORD_NEW ~ KEYWORD_CLASS ~ (LEFT_PARENTHESIS ~ ARGUMENT_EXPRESSION_LIST? ~ RIGHT_PARENTHESIS)? ~ CLASS_BASE_CLAUSE? ~ CLASS_INTERFACE_CLAUSE? ~ LEFT_CURLY_BRACE ~ CLASS_MEMBER_DECLARATIONS? ~ RIGHT_CURLY_BRACE
}
CLASS_TYPE_DESIGNATOR                  = _{ QUALIFIED_NAME | NEW_VARIABLE }
NEW_VARIABLE                           =  { NEW_VARIABLE_BASE ~ NEW_VARIABLE_SUFFIX* }
NEW_VARIABLE_BASE                      = _{
    SIMPLE_VARIABLE
  | QUALIFIED_NAME ~ OPERATOR_SCOPE_RESOLUTION ~ SIMPLE_VARIABLE
  | RELATIVE_SCOPE ~ OPERATOR_SCOPE_RESOLUTION ~ SIMPLE_VARIABLE
}
NEW_VARIABLE_SUFFIX                    = _{
    LEFT_SQUARE_BRACKET ~ EXPRESSION? ~ RIGHT_SQUARE_BRACKET
  | LEFT_CURLY_BRACE ~ EXPRESSION ~ RIGHT_CURLY_BRACE
  | OPERATOR_OBJECT ~ MEMBER_NAME
  | OPERATOR_SCOPE_RESOLUTION ~ SIMPLE_VARIABLE
}
ARRAY_INITIALIZER_LIST                 =  { ARRAY_ELEMENT_INITIALIZER ~ (LIST_SEPARATOR ~ ARRAY_ELEMENT_INITIALIZER)* }
ARRAY_ELEMENT_INITIALIZER              = _{
    OPERATOR_BITWISE_AND? ~ ELEMENT_VALUE
  | ELEMENT_KEY ~ OPERATOR_ARRAY_ASSOCIATION ~ OPERATOR_BITWISE_AND? ~ ELEMENT_VALUE
}
ELEMENT_KEY                            =  { EXPRESSION }
ELEMENT_VALUE                          =  { EXPRESSION }
SUBSCRIPT_EXPRESSION                   =  {
    DEREFERENCABLE_EXPRESSION ~ LEFT_SQUARE_BRACKET ~ EXPRESSION? ~ RIGHT_SQUARE_BRACKET
  | DEREFERENCABLE_EXPRESSION ~ LEFT_CURLY_BRACE ~ EXPRESSION ~ RIGHT_CURLY_BRACE
}
FUNCTION_CALL_EXPRESSION               =  { (QUALIFIED_NAME | CALLABLE_EXPRESSION) ~ LEFT_PARENTHESIS ~ (ARGUMENT_EXPRESSION_LIST? | ARGUMENT_EXPRESSION_LIST ~ LIST_SEPARATOR) ~ RIGHT_PARENTHESIS }
ARGUMENT_EXPRESSION_LIST               =  { ARGUMENT_EXPRESSION ~ (LIST_SEPARATOR ~ ARGUMENT_EXPRESSION)* }
ARGUMENT_EXPRESSION                    =  { VARIADIC_UNPACKING | EXPRESSION }
VARIADIC_UNPACKING                     =  { OPERATOR_ELLIPSIS ~ EXPRESSION }
MEMBER_ACCESS_EXPRESSION               =  { DEREFERENCABLE_EXPRESSION ~ OPERATOR_OBJECT ~ MEMBER_NAME }
MEMBER_NAME                            =  { NAME | SIMPLE_VARIABLE | LEFT_CURLY_BRACE ~ EXPRESSION ~ RIGHT_CURLY_BRACE }

///////////////////////// Continue from here
MEMBER_CALL_EXPRESSION = {
    DEREFERENCABLE_EXPRESSION ~ "->" ~ MEMBER_NAME ~ "(" ~ ARGUMENT_EXPRESSION_LIST? ~ ")"
  | DEREFERENCABLE_EXPRESSION ~ "->" ~ MEMBER_NAME ~ "(" ~ ARGUMENT_EXPRESSION_LIST ~ "," ~ ")"
}

POSTFIX_INCREMENT_EXPRESSION = { VARIABLE ~ "++" }

POSTFIX_DECREMENT_EXPRESSION = { VARIABLE ~ "--" }

PREFIX_INCREMENT_EXPRESSION = { "++" ~ VARIABLE }

PREFIX_DECREMENT_EXPRESSION = { "--" ~ VARIABLE }

SHELL_COMMAND_EXPRESSION = { "`" ~ DQ_CHAR_SEQUENCE? ~ "`" }

SCOPED_PROPERTY_ACCESS_EXPRESSION = {
    SCOPE_RESOLUTION_QUALIFIER ~ "::" ~ SIMPLE_VARIABLE
}

SCOPED_CALL_EXPRESSION = {
    SCOPE_RESOLUTION_QUALIFIER ~ "::" ~ MEMBER_NAME ~ "(" ~ ARGUMENT_EXPRESSION_LIST? ~ ")"
  | SCOPE_RESOLUTION_QUALIFIER ~ "::" ~ MEMBER_NAME ~ "(" ~ ARGUMENT_EXPRESSION_LIST ~ "," ~ ")"
}

CLASS_CONSTANT_ACCESS_EXPRESSION = {
    SCOPE_RESOLUTION_QUALIFIER ~ "::" ~ NAME
}

SCOPE_RESOLUTION_QUALIFIER = {
    RELATIVE_SCOPE
  | QUALIFIED_NAME
  | DEREFERENCABLE_EXPRESSION
}

RELATIVE_SCOPE = { "self" | "parent" | "static" }

CLONE_EXPRESSION = {
    PRIMARY_EXPRESSION
  | "clone" ~ PRIMARY_EXPRESSION
}

EXPONENTIATION_EXPRESSION = {
    CLONE_EXPRESSION
  | CLONE_EXPRESSION ~ "**" ~ EXPONENTIATION_EXPRESSION
}

UNARY_EXPRESSION = {
    EXPONENTIATION_EXPRESSION
  | UNARY_OP_EXPRESSION
  | ERROR_CONTROL_EXPRESSION
  | CAST_EXPRESSION
}

UNARY_OP_EXPRESSION = {
    UNARY_OPERATOR ~ UNARY_EXPRESSION
}

UNARY_OPERATOR = { "+" | "-" | "~" }

ERROR_CONTROL_EXPRESSION = {
    "@" ~ UNARY_EXPRESSION
}

CAST_EXPRESSION = {
    "(" ~ CAST_TYPE ~ ")" ~ UNARY_EXPRESSION
}

CAST_TYPE = { "array" | "binary" | "bool" | "boolean" | "double" | "int" | "integer" | "float" | "object" | "real" | "string" | "unset" }

INSTANCEOF_EXPRESSION = {
    UNARY_EXPRESSION
  | INSTANCEOF_SUBJECT ~ "instanceof" ~ CLASS_TYPE_DESIGNATOR
}

INSTANCEOF_SUBJECT = { INSTANCEOF_EXPRESSION }

LOGICAL_NOT_EXPRESSION = {
    INSTANCEOF_EXPRESSION
  | "!" ~ INSTANCEOF_EXPRESSION
}

MULTIPLICATIVE_EXPRESSION = {
    LOGICAL_NOT_EXPRESSION
  | MULTIPLICATIVE_EXPRESSION ~ "*" ~ LOGICAL_NOT_EXPRESSION
  | MULTIPLICATIVE_EXPRESSION ~ "/" ~ LOGICAL_NOT_EXPRESSION
  | MULTIPLICATIVE_EXPRESSION ~ "%" ~ LOGICAL_NOT_EXPRESSION
}

ADDITIVE_EXPRESSION = {
    MULTIPLICATIVE_EXPRESSION
  | ADDITIVE_EXPRESSION ~ "+" ~ MULTIPLICATIVE_EXPRESSION
  | ADDITIVE_EXPRESSION ~ "-" ~ MULTIPLICATIVE_EXPRESSION
  | ADDITIVE_EXPRESSION ~ "." ~ MULTIPLICATIVE_EXPRESSION
}

SHIFT_EXPRESSION = {
    ADDITIVE_EXPRESSION
  | SHIFT_EXPRESSION ~ "<<" ~ ADDITIVE_EXPRESSION
  | SHIFT_EXPRESSION ~ ">>" ~ ADDITIVE_EXPRESSION
}

RELATIONAL_EXPRESSION = {
    SHIFT_EXPRESSION
  | RELATIONAL_EXPRESSION ~ "<" ~ SHIFT_EXPRESSION
  | RELATIONAL_EXPRESSION ~ ">" ~ SHIFT_EXPRESSION
  | RELATIONAL_EXPRESSION ~ "<=" ~ SHIFT_EXPRESSION
  | RELATIONAL_EXPRESSION ~ ">=" ~ SHIFT_EXPRESSION
  | RELATIONAL_EXPRESSION ~ "<=>" ~ SHIFT_EXPRESSION
}

EQUALITY_EXPRESSION = {
    RELATIONAL_EXPRESSION
  | EQUALITY_EXPRESSION ~ "==" ~ RELATIONAL_EXPRESSION
  | EQUALITY_EXPRESSION ~ "!=" ~ RELATIONAL_EXPRESSION
  | EQUALITY_EXPRESSION ~ "<>" ~ RELATIONAL_EXPRESSION
  | EQUALITY_EXPRESSION ~ "===" ~ RELATIONAL_EXPRESSION
  | EQUALITY_EXPRESSION ~ "!==" ~ RELATIONAL_EXPRESSION
}

BITWISE_AND_EXPRESSION = {
    EQUALITY_EXPRESSION
  | BITWISE_AND_EXPRESSION ~ "&" ~ EQUALITY_EXPRESSION
}

BITWISE_EXC_OR_EXPRESSION = {
    BITWISE_AND_EXPRESSION
  | BITWISE_EXC_OR_EXPRESSION ~ "^" ~ BITWISE_AND_EXPRESSION
}

BITWISE_INC_OR_EXPRESSION = {
    BITWISE_EXC_OR_EXPRESSION
  | BITWISE_INC_OR_EXPRESSION ~ "|" ~ BITWISE_EXC_OR_EXPRESSION
}

LOGICAL_AND_EXPRESSION_1 = {
    BITWISE_INC_OR_EXPRESSION
  | LOGICAL_AND_EXPRESSION_1 ~ "&&" ~ BITWISE_INC_OR_EXPRESSION
}

LOGICAL_INC_OR_EXPRESSION_1 = {
    LOGICAL_AND_EXPRESSION_1
  | LOGICAL_INC_OR_EXPRESSION_1 ~ "||" ~ LOGICAL_AND_EXPRESSION_1
}

COALESCE_EXPRESSION = {
    LOGICAL_INC_OR_EXPRESSION_1
  | LOGICAL_INC_OR_EXPRESSION_1 ~ "??" ~ COALESCE_EXPRESSION
}

CONDITIONAL_EXPRESSION = {
    COALESCE_EXPRESSION
  | CONDITIONAL_EXPRESSION ~ "?" ~ EXPRESSION? ~ ":" ~ COALESCE_EXPRESSION
}

ASSIGNMENT_EXPRESSION = {
    CONDITIONAL_EXPRESSION
  | SIMPLE_ASSIGNMENT_EXPRESSION
  | COMPOUND_ASSIGNMENT_EXPRESSION
}

SIMPLE_ASSIGNMENT_EXPRESSION = {
    VARIABLE ~ "=" ~ ASSIGNMENT_EXPRESSION
  | LIST_INTRINSIC ~ "=" ~ ASSIGNMENT_EXPRESSION
}

LIST_INTRINSIC = {
    "list" ~ "(" ~ LIST_EXPRESSION_LIST ~ ")"
}

LIST_EXPRESSION_LIST = {
    UNKEYED_LIST_EXPRESSION_LIST
  | KEYED_LIST_EXPRESSION_LIST ~ ","?
}

UNKEYED_LIST_EXPRESSION_LIST = {
    LIST_OR_VARIABLE
  | ","
  | UNKEYED_LIST_EXPRESSION_LIST ~ "," ~ LIST_OR_VARIABLE?
}

KEYED_LIST_EXPRESSION_LIST = {
    EXPRESSION ~ "=>" ~ LIST_OR_VARIABLE
  | KEYED_LIST_EXPRESSION_LIST ~ "," ~ EXPRESSION ~ "=>" ~ LIST_OR_VARIABLE
}

LIST_OR_VARIABLE = {
    LIST_INTRINSIC
  | "&"? ~ VARIABLE
}

BYREF_ASSIGNMENT_EXPRESSION = {
    VARIABLE ~ "=" ~ "&" ~ VARIABLE
}

COMPOUND_ASSIGNMENT_EXPRESSION = {
    VARIABLE ~ COMPOUND_ASSIGNMENT_OPERATOR ~ ASSIGNMENT_EXPRESSION
}

COMPOUND_ASSIGNMENT_OPERATOR = { "**=" | "*=" | "/=" | "%=" | "+=" | "-=" | ".=" | "<<=" | ">>=" | "&=" | "^=" | "|=" }

YIELD_FROM_EXPRESSION = {
    "yield from" ~ ASSIGNMENT_EXPRESSION
}

YIELD_EXPRESSION = {
    YIELD_FROM_EXPRESSION
  | "yield"
  | "yield" ~ YIELD_EXPRESSION
  | "yield" ~ YIELD_FROM_EXPRESSION ~ "=>" ~ YIELD_EXPRESSION
}

PRINT_EXPRESSION = {
    YIELD_EXPRESSION
  | "print" ~ PRINT_EXPRESSION
}

LOGICAL_AND_EXPRESSION_2 = {
    PRINT_EXPRESSION
  | LOGICAL_AND_EXPRESSION_2 ~ "and" ~ YIELD_EXPRESSION
}

LOGICAL_EXC_OR_EXPRESSION = {
    LOGICAL_AND_EXPRESSION_2
  | LOGICAL_EXC_OR_EXPRESSION ~ "xor" ~ LOGICAL_AND_EXPRESSION_2
}

LOGICAL_INC_OR_EXPRESSION_2 = {
    LOGICAL_EXC_OR_EXPRESSION
  | LOGICAL_INC_OR_EXPRESSION_2 ~ "or" ~ LOGICAL_EXC_OR_EXPRESSION
}

EXPRESSION = {
    LOGICAL_INC_OR_EXPRESSION_2
  | INCLUDE_EXPRESSION
  | INCLUDE_ONCE_EXPRESSION
  | REQUIRE_EXPRESSION
  | REQUIRE_ONCE_EXPRESSION
}

INCLUDE_EXPRESSION = { "include" ~ EXPRESSION }

INCLUDE_ONCE_EXPRESSION = { "include_once" ~ EXPRESSION }

REQUIRE_EXPRESSION = { "require" ~ EXPRESSION }

REQUIRE_ONCE_EXPRESSION = { "require_once" ~ EXPRESSION }

CONSTANT_EXPRESSION = { EXPRESSION }

// TYPE_SCALAR  = { TYPE_BOOLEAN | TYPE_INTEGER | TYPE_FLOAT | TYPE_STRING | TYPE_NULL }
// TYPE_BOOLEAN = { "bool" | "boolean" }
// TYPE_INTEGER = { "int" | "integer" }
// TYPE_FLOAT   = { "float" | "double" | "real" }
// TYPE_STRING  = { "string" }
// TYPE_NULL    = { "null" }

// Compound Types

/*
    arrays
    objects
    resource
*/

// Strings

/*
    str-numeric::
    str-whitespace(opt)   sign(opt)   str-number

    str-whitespace::
    str-whitespace(opt)   str-whitespace-char

    str-whitespace-char::
    new-line
    Space character (0x20)
    Horizontal-tab character (0x09)
    Vertical-tab character (0x0B)
    Form-feed character (0x0C)

    str-number::
    digit-sequence
    floating-literal
*/
